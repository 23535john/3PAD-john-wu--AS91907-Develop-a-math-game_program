Based on my version 2  start to improve my code further: Here are the change evidence has been made . 
First File: Main.py (formerly Main File)
Key Improvements:
Replaced tuple-based page registration with dictionary for scalability
Added intelligent window sizing based on page type
Implemented automatic window centering for menu pages
Added proper resource cleanup on window close

class MathAdventureGame(tk.Tk):
    def __init__(self):
        # ... [initialization code] ...
        
    def _setup_container(self):
        self.container = tk.Frame(self)
        self.container.pack(fill='both', expand=True)
        self.container.grid_rowconfigure(0, weight=1)
        self.container.grid_columnconfigure(0, weight=1)

    def _register_pages(self):
        game_pages = {
            'StartPage': StartPage,
            'PlayerInfoMapPage': PlayerInfoMapPage,
            'GamePage': GamePage,
            'LeaderboardPage': LeaderboardPage
        }
        self.page_frames = {}
        for page_name, page_class in game_pages.items():
            frame = page_class(parent=self.container, controller=self)
            self.page_frames[page_name] = frame
            frame.grid(row=0, column=0, sticky='nsew')
    
    def _adjust_window_size(self, page_name):
        large_pages = ['PlayerInfoMapPage', 'GamePage']
        if page_name in large_pages:
            self.geometry('1100x800')
            self.resizable(True, True)
        else:
            self.geometry('780x620')
            self.resizable(False, False)
            self.update_idletasks()
            x = (self.winfo_screenwidth() // 2) - (780 // 2)
            y = (self.winfo_screenheight() // 2) - (620 // 2)
            self.geometry(f'780x620+{x}+{y}')

Improve my Player Information Page Enhancement
Key Improvements:

Added player name uniqueness check against leaderboard  / Implemented smart name suggestions for duplicates / Added floating SpongeBob-themed decorations
  
*Removed character selection to simplify UI
Enhanced visual design with themed colors and elements

File: Game_core.py
class PlayerInfoMapPage(tk.Frame):
    def confirm_name(self):
        # ... [validation code] ...
        
        # Check for duplicate names in leaderboard
        existing_records = score_manager.get_records()
        existing_names = [record.get('player', '').lower() for record in existing_records]
        
        if name.lower() in existing_names:
            suggestions = [f"{name}1", f"{name}2", f"{name}2024"]
            self.name_validation_label.config(
                text=f'‚ùå "{name}" already exists!\nüí° Try: {", ".join(suggestions)}', 
                fg='red'
            )
            return
        
    def _add_floating_decorations(self):
        decorations = ['‚≠ê', 'üêö', 'üåä', 'üêô', 'ü¶Ä', 'üé®']
        positions = [(0.1, 0.1), (0.9, 0.1), ...]
        for i, (relx, rely) in enumerate(positions):
            deco_label = tk.Label( ... )
            deco_label.place(relx=relx, rely=rely, anchor='center')

Jellyfish Management System
File: game_objects.py (new file)
Key Improvements:

Created dedicated class for jellyfish management
*Implemented collision detection algorithm  
Added press/release visual feedback
Used actual jellyfish images instead of circles
Improved natural movement with wave patterns

class JellyfishManager:
    def __init__(self, canvas, difficulty):
        self.jellyfish_images = self._load_jellyfish_images()
        
    def animate(self):
        # Collision detection
        min_distance = 100
        for other_jelly in self.jellyfish:
            if other_jelly != jelly:
                dx = new_x - other_jelly['x']
                dy = new_y - other_jelly['y']
                distance = math.sqrt(dx*dx + dy*dy)
                if distance < min_distance:
                    push_x = (dx / distance) * (min_distance - distance) * 0.5
                    push_y = (dy / distance) * (min_distance - distance) * 0.5
                    new_x += push_x
                    new_y += push_y
    
    def press_jellyfish(self, jelly_index):
        # Visual feedback
        self.canvas.itemconfig(jelly['bubble'], fill='#FFD700', outline='#FFA500', width=4)
        self.canvas.scale(jelly['jelly_id'], jelly['x'], jelly['y']-20, 1.1, 1.1)
        
    def release_jellyfish(self, jelly_index):
        # Revert visual changes
        self.canvas.itemconfig(jelly['bubble'], fill='#F4E4BC', outline='#DAA520', width=2)
        self.canvas.scale(jelly['jelly_id'], jelly['x'], jelly['y']-25, 1.0, 1.0)

Game Page UI and Flow Enhancements
File: Game_core.py
Key Improvements:

Added themed containers and visual decorations
Implemented custom completion dialog with options
Added duplicate click prevention
Enhanced feedback messages with encouraging text
Improved answer validation logic

class GamePage(tk.Frame):
    def _create_widgets(self):
        # Added themed containers and decorations
        question_container = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        canvas_container = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        feedback_container = tk.Frame(main_frame, bg='#87CEEB', bd=3, relief='raised')
        
    def game_completed(self):
        # Custom dialog with options
        dialog = tk.Toplevel()
        # Play Again, Back to Menu, View Leaderboard buttons
        
    def check_answer(self, selected):
        # Prevent multiple clicks
        if hasattr(self, '_answer_checked') and self._answer_checked:
            return
        self._answer_checked = True

Problem Generation System Overhaul
File: utils.py  Key Improvements:

Added 3 difficulty levels with multiple problem types

Created SpongeBob-themed context for all problems
Implemented intelligent distractor generation
Added geometry problem type for higher difficulty
Improved problem variety and educational value

class ProblemGenerator:
    def _make_easy_one(self):
        what_kind = random.choice(['math', 'counting', 'money'])
        if what_kind == 'math': return self._basic_math()
        elif what_kind == 'counting': return self._counting_stuff()
        else: return self._money_stuff()
        
    def _basic_math(self):
        # SpongeBob-themed problems
        thing = random.choice(self.stuff)
        problem = f"SpongeBob has {num1} {thing}s. If he gets {num2} times more..."
        
    def _geometry_problem(self):
        what_kind = random.choice(['area', 'perimeter'])
        # ... geometry problems ...
Leaderboard and Score Management
File: game_objects.py
Key Improvements:

Added gold highlighting for current player
Implemented score timestamp recording
Enhanced UI with themed borders
Improved scrolling and layout
Fixed score sorting and saving
class LeaderboardPage(tk.Frame):
    def refresh(self):
        # Highlight current player
        if i == highlight_index:
            bg_color = '#FFD700'  # Gold highlight
        
    def _create_widgets(self):
        # Added themed border
        border_frame = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        
class ScoreManager:
    def save_result(self, name, points, difficulty):
        # Add timestamp
        new_record = {
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
        }
 Audio System Improvements
File: utils.py
Key Improvements:

Added graceful degradation when pygame unavailable

Improved error messages

Better resource cleanup

Fixed music toggle feedback
class AudioManager:
    def __init__(self):
        if not pygame_works:
            print("Sound is turned off - pygame not available")
            return
        try:
            pygame.mixer.init()
            # ... load sounds ...
        except Exception as e:
            print(f"Couldn't start sound: {e}")
            self.sounds_work = False

Final changes of the  version :All the files stored:
Main file:import tkinter as tk
from Game_core import StartPage, PlayerInfoMapPage, GamePage
from game_objects import LeaderboardPage  # ‰ªéÊñ∞Êñá‰ª∂ÂØºÂÖ•ÊéíË°åÊ¶ú
from utils import AudioManager as SoundManager

class MathAdventureGame(tk.Tk):
    def __init__(self):
        super().__init__()
        
        # ÈÖçÁΩÆ‰∏ªÁ™óÂè£
        self.title('Êµ∑ÁªµÂÆùÂÆùÊï∞Â≠¶ÂÜíÈô©')
        self.geometry('780x620')
        
        # Â∞ùËØïËÆæÁΩÆÁ™óÂè£ÂõæÊ†á
        try:
            self.iconbitmap('assets/Images/spongebob.ico')
        except Exception:
            pass
        
        # ÂàùÂßãÂåñÊ∏∏ÊàèÁä∂ÊÄÅÂèòÈáè
        self.player_name = ''  # Áé©ÂÆ∂ÂêçÁß∞
        self.selected_difficulty = 'Easy'  # ÈªòËÆ§ÈöæÂ∫¶
        self.page_history = []  # È°µÈù¢ÂéÜÂè≤ËÆ∞ÂΩï
        self.last_score = None  # ‰∏ä‰∏ÄÊ¨°Ê∏∏ÊàèÂàÜÊï∞
        
        # ËÆæÁΩÆÈü≥È¢ëÁÆ°ÁêÜÂô®
        self.sound_manager = SoundManager()
        
        # ÂàõÂª∫È°µÈù¢ÂÆπÂô®
        self._setup_container()
        
        # Ê≥®ÂÜåÊâÄÊúâÈ°µÈù¢
        self._register_pages()
        
        # ËÆæÁΩÆÂàùÂßãÈ°µÈù¢
        self.current_page = 'StartPage'
        self._show_frame('StartPage')

    def _setup_container(self):
        self.container = tk.Frame(self)
        self.container.pack(fill='both', expand=True)
        self.container.grid_rowconfigure(0, weight=1)
        self.container.grid_columnconfigure(0, weight=1)

    def _register_pages(self):
        # È°µÈù¢ÂàóË°®
        game_pages = {
            'StartPage': StartPage,
            'PlayerInfoMapPage': PlayerInfoMapPage,
            'GamePage': GamePage,
            'LeaderboardPage': LeaderboardPage  # ‰ΩøÁî®Êñ∞‰ΩçÁΩÆÁöÑÊéíË°åÊ¶ú
        }
        
        # È°µÈù¢Ê°ÜÊû∂Â≠óÂÖ∏
        self.page_frames = {}
        
        # ÂàõÂª∫Âπ∂Ê≥®ÂÜåÊØè‰∏™È°µÈù¢
        for page_name, page_class in game_pages.items():
            frame = page_class(parent=self.container, controller=self)
            self.page_frames[page_name] = frame
            frame.grid(row=0, column=0, sticky='nsew')

    def _show_frame(self, page_name):
        # Êõ¥Êñ∞È°µÈù¢ÂéÜÂè≤ËÆ∞ÂΩï
        if self.current_page and self.current_page != page_name and self.current_page != 'StartPage':
            self.page_history.append(self.current_page)
        
        # Ëé∑ÂèñÁõÆÊ†áÈ°µÈù¢
        target_frame = self.page_frames[page_name]
        
        # Ê†πÊçÆÈ°µÈù¢Ë∞ÉÊï¥Á™óÂè£Â§ßÂ∞è
        self._adjust_window_size(page_name)
        
        # È°µÈù¢ÊòæÁ§∫ÂâçÂ§ÑÁêÜ
        self._pre_display_processing(page_name, target_frame)
        
        # ÊâßË°åÈ°µÈù¢ÂàáÊç¢
        self.current_page = page_name
        target_frame.tkraise()
        
        # Â¶ÇÊûúÊòØËèúÂçïÈ°µÈù¢ÔºåÁ°Æ‰øùÁ™óÂè£Áä∂ÊÄÅÊ≠£Á°Æ
        if page_name == 'StartPage':
            self.update_idletasks()
            # Âº∫Âà∂Êõ¥Êñ∞Á™óÂè£Áä∂ÊÄÅ
            self.after(100, self._ensure_menu_size)
    
    def _ensure_menu_size(self):
        """Á°Æ‰øùËèúÂçïÈ°µÈù¢‰øùÊåÅÊ≠£Á°ÆÂ§ßÂ∞è"""
        if self.current_page == 'StartPage':
            current_geometry = self.geometry()
            if '780x620' not in current_geometry:
                self._reset_to_menu_size()

    def _adjust_window_size(self, page_name):
        # ÈúÄË¶ÅËæÉÂ§ßÂ∞∫ÂØ∏ÁöÑÈ°µÈù¢
        large_pages = ['PlayerInfoMapPage', 'GamePage']
        
        if page_name in large_pages:
            # Á°Æ‰øùÁ™óÂè£‰∏çÊòØÊúÄÂ§ßÂåñÁä∂ÊÄÅ
            try:
                self.state('normal')
            except:
                pass
            self.geometry('1100x800')
            self.resizable(True, True)  # ÂÖÅËÆ∏Ë∞ÉÊï¥Â§ßÂ∞è
        else:
            # ËèúÂçïÈ°µÈù¢ - Âº∫Âà∂ÈáçÁΩÆÂà∞ÂéüÂßãÂ§ßÂ∞èÂπ∂Â±Ö‰∏≠
            # Á°Æ‰øùÁ™óÂè£‰∏çÊòØÊúÄÂ§ßÂåñÁä∂ÊÄÅ
            try:
                self.state('normal')
            except:
                pass
            self.geometry('780x620')
            self.resizable(False, False)  # ËèúÂçïÈ°µÈù¢‰∏çÂÖÅËÆ∏Ë∞ÉÊï¥Â§ßÂ∞è
            
            # Á°Æ‰øùÁ™óÂè£Â±Ö‰∏≠ÊòæÁ§∫
            self.update_idletasks()  # Êõ¥Êñ∞Á™óÂè£‰ø°ÊÅØ
            x = (self.winfo_screenwidth() // 2) - (780 // 2)
            y = (self.winfo_screenheight() // 2) - (620 // 2)
            self.geometry(f'780x620+{x}+{y}')

    def _pre_display_processing(self, page_name, frame):
        # Ê∏∏ÊàèÈ°µÈù¢ÈúÄË¶ÅÈáçÁΩÆÊ∏∏Êàè
        if page_name == 'GamePage':
            if not frame.reset_game():
                return
        
        # ÊéíË°åÊ¶úÈ°µÈù¢ÈúÄË¶ÅÂà∑Êñ∞Êï∞ÊçÆ
        if page_name == 'LeaderboardPage':
            frame.refresh()

    def show_frame(self, page_name):
        self._show_frame(page_name)

    def go_to_previous_page(self):
        if self.page_history:
            previous_page = self.page_history.pop()
            self._show_frame(previous_page)
        else:
            # Á°Æ‰øùËøîÂõûËèúÂçïÊó∂ÈáçÁΩÆÁ™óÂè£Â§ßÂ∞è
            self._show_frame('StartPage')
    
    def _reset_to_menu_size(self):
        """Âº∫Âà∂ÈáçÁΩÆÁ™óÂè£Âà∞ËèúÂçïÂ§ßÂ∞è"""
        # Â¶ÇÊûúÁ™óÂè£Ë¢´ÊúÄÂ§ßÂåñÔºåÂÖàÊÅ¢Â§çÊ≠£Â∏∏Áä∂ÊÄÅ
        try:
            self.state('normal')
        except:
            pass
        
        self.geometry('780x620')
        self.resizable(False, False)
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (780 // 2)
        y = (self.winfo_screenheight() // 2) - (620 // 2)
        self.geometry(f'780x620+{x}+{y}')

    def on_window_close(self):
        self.sound_manager.stop_bg_music()
        self.destroy()

    def destroy(self):
        # Ê∏ÖÁêÜÈü≥È¢ëËµÑÊ∫ê
        self.sound_manager.cleanup()
        # Ë∞ÉÁî®Áà∂Á±ªÈîÄÊØÅÊñπÊ≥ï
        super().destroy()

# Á®ãÂ∫èÂÖ•Âè£
if __name__ == '__main__':
    # ÂàõÂª∫Ê∏∏ÊàèÂ∫îÁî®ÂÆû‰æã
    game_app = MathAdventureGame()
    
    # ÁªëÂÆöÁ™óÂè£ÂÖ≥Èó≠‰∫ã‰ª∂
    game_app.protocol("WM_DELETE_WINDOW", game_app.on_window_close)
    
    # ÂêØÂä®‰∏ª‰∫ã‰ª∂Âæ™ÁéØ
    game_app.mainloop()


Game_core file:

import tkinter as tk
from tkinter import messagebox
from utils import ProblemGenerator as ProblemBank, ScoreManager
from game_objects import JellyfishManager  # ‰ªéÊñ∞Êñá‰ª∂ÂØºÂÖ•

# Ê∏∏ÊàèÈÖçÁΩÆ
QUESTIONS_PER_GAME = 12
TIME_PER_QUESTION = 60
LEVEL_NAMES = {
    'Easy': "Jellyfish Fields",
    'Medium': "Krusty Krab",
    'Hard': "Squidward's House"
}
LEVEL_POINTS = {'Easy': 50, 'Medium': 100, 'Hard': 300}
BACKGROUND_COLORS = {
    'Easy': '#88cfff',   # ÊµÖËìù - Ê∞¥ÊØçÁî∞
    'Medium': '#ff9966', # ÊµÖÊ©ô - ËüπÂ†°Áéã
    'Hard': '#9b59b6'    # ÊµÖÁ¥´ - Á´†È±ºÂì•ÁöÑÂÆ∂
}

STATUS_BAR_COLOR = '#3A6EA5'  # Ê∑±ËìùÁä∂ÊÄÅÊ†è
TEXT_COLOR = '#2C3E50'        # Ê∑±ËìùÊñáÊú¨

class StartPage(tk.Frame):
    def __init__(self, parent, controller):
        super().__init__(parent, bg='#76deee')
        self.controller = controller
        self._create_widgets()
    
    def _create_widgets(self):
        """ÂàõÂª∫UIÂÖÉÁ¥†"""
        # ËÉåÊôØÂõæÁâá
        try:
            bg_image = tk.PhotoImage(file='assets/Images/bg_menu.png')
            bg_label = tk.Label(self, image=bg_image)
            bg_label.image = bg_image
            bg_label.place(x=0, y=0, relwidth=1, relheight=1)
        except Exception:
            # ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•Êó∂ÁöÑÂõûÈÄÄÊñπÊ°à
            self.config(bg='#82d4ed')
        
        # Ê†áÈ¢ò
        title_frame = tk.Frame(self, bg='#76deee')
        title_frame.place(relx=0.5, rely=0.2, anchor='center')
        
        # ÊåâÈíÆÊ†∑Âºè
        btn_style = {
            'font': ('Comic Sans MS', 18),
            'bg': '#FFD700', 
            'fg': 'black',
            'activebackground': '#FFA500',
            'relief': 'raised', 
            'bd': 3,
            'width': 13,
            'pady': 7
        }
        
        # ÊåâÈíÆÂÆπÂô®
        btn_frame = tk.Frame(self, bg="#76deee")
        btn_frame.place(relx=0.5, rely=0.5, anchor='center')
        
        # ÊåâÈíÆ
        tk.Button(
            btn_frame, 
            text='Start Game', 
            **btn_style,
            command=lambda: self.controller.show_frame('PlayerInfoMapPage')
        ).pack(pady=10)
        
        tk.Button(
            btn_frame, 
            text='Leaderboard', 
            **btn_style,
            command=lambda: self.controller.show_frame('LeaderboardPage')
        ).pack(pady=10)
        
        tk.Button(
            btn_frame, 
            text='Exit Game', 
            **btn_style,
            command=self.controller.destroy
        ).pack(pady=10)
        
        # Èü≥‰πêÂàáÊç¢ÊåâÈíÆ
        self.music_btn = tk.Button(
            self, 
            text='üéµ', 
            font=('Arial', 14), 
            bg="#AAFF00", 
            bd=0,
            command=self.toggle_music
        )
        self.music_btn.place(x=740, y=10)
        
    def toggle_music(self):
        """ÂàáÊç¢Èü≥‰πêÂπ∂Êõ¥Êñ∞ÊåâÈíÆ"""
        music_on = self.controller.sound_manager.toggle_music()
        self.music_btn.config(text='üéµON' if music_on else 'üîáOFF')

class PlayerInfoMapPage(tk.Frame):
    """ÂêàÂπ∂ÁöÑÁî®Êà∑‰ø°ÊÅØËæìÂÖ•ÂíåÂú∞ÂõæÈÄâÊã©È°µÈù¢"""
    def __init__(self, parent, controller):
        super().__init__(parent, bg='#FFE4B5')  # Êõ¥Êîπ‰∏∫Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢òÁöÑÊ©ôËâ≤
        self.controller = controller
        self._create_widgets()
        self.name_confirmed = False
    
    def _create_widgets(self):
        """ÂàõÂª∫UIÂÖÉÁ¥†"""
        # ËÉåÊôØ - Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢ò
        try:
            bg_image = tk.PhotoImage(file='assets/Images/krusty_krab.png')
            bg_label = tk.Label(self, image=bg_image)
            bg_label.image = bg_image
            bg_label.place(x=0, y=0, relwidth=1, relheight=1)
        except Exception:
            self.config(bg='#FFE4B5')  # Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢òÊ©ôËâ≤ËÉåÊôØ
        
        # Ê†áÈ¢ò - Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢òÂ¢ûÂº∫ÁâàÊú¨
        title_frame = tk.Frame(self, bg='#FFE4B5')
        title_frame.place(relx=0.5, rely=0.05, anchor='center')
        
        # Ê∑ªÂä†Ê¨¢ËøéË£ÖÈ•∞
        welcome_frame = tk.Frame(title_frame, bg='#FFE4B5')
        welcome_frame.pack(pady=5)
        
        tk.Label(
            welcome_frame, 
            text='üåü Welcome to Bikini Bottom! üåü',
            font=('Comic Sans MS', 18, 'bold'),
            bg='#FFE4B5', 
            fg='#FFD700'
        ).pack()
        
        tk.Label(
            welcome_frame, 
            text='üêô Ready for a math adventure? üêô',
            font=('Comic Sans MS', 14),
            bg='#FFE4B5', 
            fg='#006994'
        ).pack(pady=5)
        
        # Áî®Êà∑‰ø°ÊÅØË°®ÂçïÊ°ÜÊû∂ - Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢ò
        form_frame = tk.Frame(self, bg='#FFD700', bd=5, relief='groove')  # Êµ∑ÁªµÂÆùÂÆùÈªÑËâ≤
        form_frame.place(relx=0.5, rely=0.2, anchor='center', width=400, height=250)
        
        # Áî®Êà∑ÂêçËæìÂÖ• - Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢òÁâàÊú¨
        tk.Label(
            form_frame, 
            text="Enter Your Username: üßΩ", 
            bg='#FFD700',
            font=('Comic Sans MS', 14, 'bold'),
            fg='#2C3E50'
        ).pack(pady=5)
        
        # Ê∑ªÂä†ÊèêÁ§∫ÊñáÊú¨
        tk.Label(
            form_frame,
            text='(Pick a fun username, 3-15 characters)',
            bg='#FFD700',
            font=('Comic Sans MS', 10),
            fg='#666666'
        ).pack(pady=2)
        
        self.name_var = tk.StringVar()
        name_entry = tk.Entry(
            form_frame, 
            textvariable=self.name_var, 
            font=('Comic Sans MS', 12), 
            width=25,
            relief='sunken',
            bd=2
        )
        name_entry.pack(pady=5)
        name_entry.focus_set()
        
        # Ê∑ªÂä†È™åËØÅÊèêÁ§∫Ê†áÁ≠æ
        self.name_validation_label = tk.Label(
            form_frame,
            text='',
            bg='#FFD700',
            font=('Comic Sans MS', 10),
            fg='red'
        )
        self.name_validation_label.pack(pady=2)
        
        # Ê∑ªÂä†Á°ÆËÆ§ÊåâÈíÆ
        confirm_btn = tk.Button(
            form_frame, 
            text='Confirm Name', 
            font=('Comic Sans MS', 12),
            bg='#4CAF50', 
            fg='white',
            padx=10,
            pady=5,
            command=self.confirm_name
        )
        confirm_btn.pack(pady=10)
        
        # ÁßªÈô§ËßíËâ≤ÈÄâÊã©Âå∫Âüü - ÁÆÄÂåñÁïåÈù¢
        
        # Âú∞ÂõæÊ†áÈ¢ò - Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢òÂ¢ûÂº∫ÁâàÊú¨
        map_title_frame = tk.Frame(self, bg='#FFE4B5')
        map_title_frame.place(relx=0.5, rely=0.4, anchor='center')
        
        # Ê∑ªÂä†Ë£ÖÈ•∞ÊÄßÂÖÉÁ¥†
        decoration_frame = tk.Frame(map_title_frame, bg='#FFE4B5')
        decoration_frame.pack(pady=5)
        
        tk.Label(
            decoration_frame, 
            text='‚≠ê üêö ‚≠ê',
            font=('Comic Sans MS', 16),
            bg='#FFE4B5', 
            fg='#FFD700'
        ).pack()
        
        tk.Label(
            map_title_frame, 
            text='üó∫Ô∏è Choose Your Adventure:',
            font=('Comic Sans MS', 22, 'bold'),
            bg='#FFE4B5', 
            fg='#006994'
        ).pack(pady=5)
        
        tk.Label(
            map_title_frame, 
            text='üéÆ Click on a location to start your math journey!',
            font=('Comic Sans MS', 12),
            bg='#FFE4B5', 
            fg='#666666'
        ).pack(pady=5)
        
        # Ê∑ªÂä†Êõ¥Â§öË£ÖÈ•∞
        tk.Label(
            decoration_frame, 
            text='‚≠ê üêö ‚≠ê',
            font=('Comic Sans MS', 16),
            bg='#FFE4B5', 
            fg='#FFD700'
        ).pack()
        
        # Âú∞ÂõæÈÄâÊã©Ê°ÜÊû∂
        map_frame = tk.Frame(self, bg='#FFE4B5')
        map_frame.place(relx=0.5, rely=0.65, anchor='center')
        
        # ÂÖ≥Âç°ÊèèËø∞ÂíåÈ¢úËâ≤ - Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢òÁæéÂåñÁâàÊú¨
        level_info = [
            ("üåä Jellyfish Fields\n\nüéØ Easy Difficulty\nüíé 50 points per question\n\nüêô Perfect for beginners!", '#87CEEB', 'Easy', 'üêô'),
            ("üçî Krusty Krab\n\n‚ö° Medium Difficulty\nüíé 100 points per question\n\nü¶Ä For experienced players!", '#FFB347', 'Medium', 'ü¶Ä'),
            ("üé® Squidward's House\n\nüî• Hard Difficulty\nüíé 300 points per question\n\nüé∑ Ultimate challenge!", '#DDA0DD', 'Hard', 'üé∑')
        ]
        
        for i, (desc, color, level, emoji) in enumerate(level_info):
            # ÂàõÂª∫ÊåâÈíÆÂÆπÂô®Ê°ÜÊû∂ - Êõ¥Â§ßÂ∞∫ÂØ∏
            btn_container = tk.Frame(map_frame, bg=color, bd=5, relief='raised')
            btn_container.grid(row=0, column=i, padx=20, pady=15)
            
            # Ê∑ªÂä†Ë£ÖÈ•∞ÊÄßËæπÊ°Ü
            border_frame = tk.Frame(btn_container, bg='#FFD700', bd=3, relief='sunken')
            border_frame.pack(fill='both', expand=True, padx=4, pady=4)
            
            level_btn = tk.Button(
                border_frame, 
                text=f"{emoji}\n{desc}",
                font=('Comic Sans MS', 14, 'bold'),
                bg=color, 
                fg='white', 
                width=22, 
                height=8,
                relief='flat',
                bd=0,
                activebackground='#FFD700',
                activeforeground='#2C3E50',
                cursor='hand2',
                command=lambda l=level: self.start_level(l)
            )
            level_btn.pack(fill='both', expand=True, padx=3, pady=3)
        
        # ‰∏ªËèúÂçïÊåâÈíÆ - ÁæéÂåñÁâàÊú¨
        menu_btn = tk.Button(
            self, 
            text='üè† Main Menu', 
            font=('Comic Sans MS', 14, 'bold'),
            bg='#FFD700', 
            fg='#2C3E50',
            padx=15,
            pady=8,
            relief='raised',
            bd=3,
            command=lambda: self.controller.show_frame('StartPage')
        )
        menu_btn.place(relx=0.5, rely=0.92, anchor='center')
        
        # Ê∑ªÂä†Áä∂ÊÄÅÊ†áÁ≠æ - ÁßªÂà∞Êõ¥ÂêàÈÄÇÁöÑ‰ΩçÁΩÆ
        self.status_label = tk.Label(
            self, 
            text='Please enter and confirm your name first',
            font=('Comic Sans MS', 12),
            bg='#FFE4B5',
            fg='#2C3E50'
        )
        self.status_label.place(relx=0.5, rely=0.32, anchor='center')
        
        # Ê∑ªÂä†ÊµÆÂä®Ë£ÖÈ•∞ÂÖÉÁ¥†
        self._add_floating_decorations()

    def confirm_name(self):
        """Á°ÆËÆ§Áé©ÂÆ∂ÂêçÁß∞"""
        name = self.name_var.get().strip()
        
        # Ê∏ÖÈô§‰πãÂâçÁöÑÈ™åËØÅÊ∂àÊÅØ
        self.name_validation_label.config(text='')
        
        # È™åËØÅÂêçÁß∞
        if not name:
            self.name_validation_label.config(text='‚ùå Name cannot be empty!', fg='red')
            return
            
        if len(name) < 3:
            self.name_validation_label.config(text='‚ùå Name must be at least 3 characters long!', fg='red')
            return
            
        if len(name) > 15:
            self.name_validation_label.config(text='‚ùå Name too long (max 15 characters)!', fg='red')
            return
            
        if not name.replace(" ", "").isalnum():
            self.name_validation_label.config(text='‚ùå Name can only contain letters and numbers!', fg='red')
            return
        
        # Ê£ÄÊü•ÈáçÂ§çÂêçÁß∞
        from utils import ScoreManager
        score_manager = ScoreManager()
        existing_records = score_manager.get_records()
        existing_names = [record.get('player', '').lower() for record in existing_records]
        
        if name.lower() in existing_names:
            # Êèê‰æõÊõ¥ÂÖ∑‰ΩìÁöÑÂª∫ËÆÆ
            suggestions = [
                f"{name}1", f"{name}2", f"{name}2024", f"{name}_player", 
                f"Super{name}", f"{name}Math", f"{name}Star"
            ]
            suggestion_text = ", ".join(suggestions[:3])  # Âè™ÊòæÁ§∫Ââç3‰∏™Âª∫ËÆÆ
            
            self.name_validation_label.config(
                text=f'‚ùå "{name}" already exists in the leaderboard!\nüí° Try: {suggestion_text}', 
                fg='red'
            )
            return
        
        # ÂêçÁß∞ÊúâÊïà
        self.name_confirmed = True
        self.name_validation_label.config(text='‚úÖ Name confirmed! Choose your difficulty level.', fg='green')
        self.status_label.config(text=f'Welcome, {name}! Ready to play!', fg='green')

    def start_level(self, level):
        """ÂºÄÂßãÈÄâÊã©ÁöÑÊ∏∏ÊàèÂÖ≥Âç°"""
        if not self.name_confirmed:
            self.status_label.config(text='Please confirm your name first!', fg='red')
            return
            
        name = self.name_var.get().strip()
        self.controller.player_name = name
        self.controller.selected_difficulty = level
        self.controller.show_frame('GamePage')

    # ÁßªÈô§ËßíËâ≤ÈÄâÊã©Áõ∏ÂÖ≥ÊñπÊ≥ï
    
    def _add_floating_decorations(self):
        """Ê∑ªÂä†ÊµÆÂä®Ë£ÖÈ•∞ÂÖÉÁ¥†"""
        decorations = ['‚≠ê', 'üêö', 'üåä', 'üêô', 'ü¶Ä', 'üé®']
        positions = [
            (0.1, 0.1), (0.9, 0.1), (0.1, 0.9), (0.9, 0.9),
            (0.2, 0.2), (0.8, 0.2), (0.2, 0.8), (0.8, 0.8)
        ]
        
        for i, (relx, rely) in enumerate(positions):
            if i < len(decorations):
                deco_label = tk.Label(
                    self,
                    text=decorations[i],
                    font=('Comic Sans MS', 20),
                    bg='#FFE4B5',
                    fg='#FFD700'
                )
                deco_label.place(relx=relx, rely=rely, anchor='center')
    
    def reset_player_info(self):
        """ÈáçÁΩÆÁé©ÂÆ∂‰ø°ÊÅØÈ°µÈù¢"""
        # Ê∏ÖÁ©∫ÂêçÁß∞ËæìÂÖ•
        self.name_var.set('')
        self.name_confirmed = False
        
        # ÈáçÁΩÆÈ™åËØÅÊ∂àÊÅØ
        self.name_validation_label.config(text='')
        self.status_label.config(text='Please enter and confirm your name first', fg='#2C3E50')

class GamePage(tk.Frame):
    def __init__(self, parent, controller):
        super().__init__(parent, bg='white')
        self.controller = controller
        self.jellyfish_manager = None  # Ê∞¥ÊØçÁÆ°ÁêÜÂô®
        
        # ÂÆöÊó∂Âô®ÁÆ°ÁêÜ
        self._active_timers = []
        self._game_active = False
        
        self._create_widgets()
        self.reset_game()
    
    def _create_widgets(self):
        """ÂàõÂª∫Ê∏∏ÊàèÁïåÈù¢ÂÖÉÁ¥† - Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢òÂ¢ûÂº∫Áâà"""
        # ‰∏ªÊ°ÜÊû∂ - Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢òËÉåÊôØ
        self.config(bg='#FFE4B5')  # Êµ∑ÁªµÂÆùÂÆùÊ©ôËâ≤ËÉåÊôØ
        main_frame = tk.Frame(self, bg='#FFE4B5')
        main_frame.pack(fill='both', expand=True, padx=15, pady=15)
        
        # È°∂ÈÉ®ÂØºËà™Ê†è - ÂåÖÂê´ËøîÂõûÊåâÈíÆ
        top_nav = tk.Frame(main_frame, bg='#FFD700', height=60, bd=3, relief='raised')
        top_nav.pack(fill='x', pady=(0, 10))
        top_nav.pack_propagate(False)
        
        # ËøîÂõûÂú∞ÂõæÊåâÈíÆ - ÁßªÂà∞È°∂ÈÉ®Âè≥‰æßÔºåÊõ¥ÊòæÁúº
        back_btn = tk.Button(
            top_nav, 
            text='üó∫Ô∏è Back to Map', 
            font=('Comic Sans MS', 12, 'bold'),
            bg='#FF6B35',  # Êµ∑ÁªµÂÆùÂÆùÊ©ôËâ≤
            fg='white',
            padx=15,
            pady=8,
            relief='raised',
            bd=3,
            cursor='hand2',
            command=self.return_to_map
        )
        back_btn.pack(side='right', padx=15, pady=10)
        
        # Ê∏∏ÊàèÊ†áÈ¢ò
        game_title = tk.Label(
            top_nav,
            text='üßΩ SpongeBob Math Adventure üßΩ',
            font=('Comic Sans MS', 16, 'bold'),
            bg='#FFD700',
            fg='#2C3E50'
        )
        game_title.pack(side='left', padx=15, pady=10)
    
        status_bar = tk.Frame(main_frame, bg=STATUS_BAR_COLOR, height=50)
        status_bar.pack(fill='x', pady=(0, 10))
        
        self.lives_frame = tk.Frame(status_bar, bg=STATUS_BAR_COLOR)
        self.lives_frame.pack(side='left', padx=15)
        
        try:
            self.heart_img = tk.PhotoImage(file='assets/Images/heart.png')
            self.heart_img = self.heart_img.subsample(4, 4)
        except Exception:
            self.heart_img = None
        
        self.lives_labels = []
        for i in range(3):
            if self.heart_img:
                label = tk.Label(self.lives_frame, image=self.heart_img, bg=STATUS_BAR_COLOR)
            else:
                label = tk.Label(self.lives_frame, text='‚ô•', 
                            font=('Comic Sans MS', 20), 
                            fg='#FF6B6B', bg=STATUS_BAR_COLOR)
            label.pack(side='left', padx=2)
            self.lives_labels.append(label)
        
        # ÂàÜÊï∞ÊòæÁ§∫
        self.score_label = tk.Label(
            status_bar, 
            text='Score: 0', 
            font=('Comic Sans MS', 16), 
            fg='#FFF44F',
            bg=STATUS_BAR_COLOR
        )
        self.score_label.pack(side='left', padx=15)
        
        # ËÆ°Êó∂Âô®ÊòæÁ§∫
        self.timer_label = tk.Label(
            status_bar, 
            text='Time: 20s', 
            font=('Comic Sans MS', 16), 
            fg='white', 
            bg=STATUS_BAR_COLOR
        )
        self.timer_label.pack(side='right', padx=15)
        
        # ÈóÆÈ¢òËÆ°Êï∞Âô®
        self.counter_label = tk.Label(
            status_bar, 
            text='Question: 1/12', 
            font=('Comic Sans MS', 16), 
            fg='white', 
            bg=STATUS_BAR_COLOR
        )
        self.counter_label.pack(side='right', padx=15)
    
        # ÈóÆÈ¢òÊòæÁ§∫ - Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢òÁâàÊú¨
        question_container = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        question_container.pack(fill='x', padx=15, pady=10)
        
        # ÈóÆÈ¢òÊ†áÈ¢òË£ÖÈ•∞
        question_title = tk.Label(
            question_container,
            text='üßΩ Question Time! üßΩ',
            font=('Comic Sans MS', 12, 'bold'),
            bg='#FFD700',
            fg='#2C3E50'
        )
        question_title.pack(pady=(5, 0))
        
        self.question_label = tk.Label(
            question_container, 
            text='', 
            font=('Comic Sans MS', 16, 'bold'), 
            bg='#FFD700', 
            fg='#2C3E50',
            wraplength=600,
            pady=15
        )
        self.question_label.pack(fill='x', padx=15, pady=10)
    
        # Ê∞¥ÊØçÁîªÂ∏ÉÂÆπÂô® - Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢òÂ¢ûÂº∫Áâà
        canvas_container = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        canvas_container.pack(fill='both', expand=True, pady=10)
        
        # Ê∑ªÂä†ÁîªÂ∏ÉÊ†áÈ¢òË£ÖÈ•∞
        canvas_title = tk.Frame(canvas_container, bg='#FFD700')
        canvas_title.pack(side='top', pady=(5, 0))
        
        title_label = tk.Label(
            canvas_title,
            text='üê† Catch the Jellyfish! üê†',
            font=('Comic Sans MS', 16, 'bold'),
            bg='#FFD700',
            fg='#006994'
        )
        title_label.pack(side='left', padx=15)
        
        # Ê∑ªÂä†Êµ∑ÁªµÂÆùÂÆùË£ÖÈ•∞
        decoration_label = tk.Label(
            canvas_title,
            text='üßΩ ü¶Ä üêô üê† ‚≠ê',
            font=('Comic Sans MS', 14),
            bg='#FFD700',
            fg='#FF6B35'
        )
        decoration_label.pack(side='right', padx=15)
        
        # ÁîªÂ∏ÉËæπÊ°Ü
        canvas_border = tk.Frame(canvas_container, bg='#FF6B35', bd=2, relief='sunken')
        canvas_border.pack(fill='both', expand=True, padx=5, pady=5)
    
        self.canvas = tk.Canvas(canvas_border, bg='#87CEEB', highlightthickness=0)
        self.canvas.pack(fill='both', expand=True, padx=2, pady=2)
        
        # Ê∑ªÂä†Êµ∑Ê¥ãË£ÖÈ•∞ÂÖÉÁ¥†
        self._add_ocean_decorations()
    
        # ÂèçÈ¶àÊ†áÁ≠æ - Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢òÁâàÊú¨
        feedback_container = tk.Frame(main_frame, bg='#87CEEB', bd=3, relief='raised')
        feedback_container.pack(fill='x', pady=10)
        
        # ÂèçÈ¶àÊ†áÈ¢òË£ÖÈ•∞
        feedback_title = tk.Label(
            feedback_container,
            text='üí¨ Feedback Zone üí¨',
            font=('Comic Sans MS', 10, 'bold'),
            bg='#87CEEB',
            fg='#2C3E50'
        )
        feedback_title.pack(pady=(3, 0))
        
        self.feedback_label = tk.Label(
            feedback_container, 
            text='', 
            font=('Comic Sans MS', 14, 'bold'), 
            bg='#87CEEB',
            fg='#2C3E50',
            height=1
        )
        self.feedback_label.pack(fill='x', padx=10, pady=5)
    
        # Â∫ïÈÉ®Ë£ÖÈ•∞Ê†è - Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢ò
        bottom_decor = tk.Frame(main_frame, bg='#FFD700', height=40, bd=2, relief='sunken')
        bottom_decor.pack(side='bottom', fill='x', pady=(10, 0))
        bottom_decor.pack_propagate(False)
        
        # Ê∑ªÂä†Êµ∑ÁªµÂÆùÂÆù‰∏ªÈ¢òË£ÖÈ•∞
        decor_label = tk.Label(
            bottom_decor,
            text='üêô ü¶Ä üßΩ üê† ‚≠ê üêö',
            font=('Comic Sans MS', 14),
            bg='#FFD700',
            fg='#FF6B35'
        )
        decor_label.pack(expand=True, pady=8)
    
    def _add_ocean_decorations(self):
        """Ê∑ªÂä†Êµ∑Ê¥ãË£ÖÈ•∞ÂÖÉÁ¥†"""
        # Ê∑ªÂä†Ê∞îÊ≥°Ë£ÖÈ•∞
        for i in range(8):
            x = 30 + i * 80
            y = 20 + (i % 3) * 15
            self.canvas.create_oval(
                x, y, x+8, y+8,
                fill='', outline='#E0F6FF', width=1,
                tags='decoration'
            )
        
        # Ê∑ªÂä†Êµ∑ÊòüË£ÖÈ•∞
        for i in range(4):
            x = 60 + i * 120
            y = 40 + (i % 2) * 20
            self.canvas.create_text(
                x, y, text='‚≠ê',
                font=('Comic Sans MS', 10),
                fill='#FFD700',
                tags='decoration'
            )
        
        # Ê∑ªÂä†ÁèäÁëöË£ÖÈ•∞
        for i in range(3):
            x = 50 + i * 150
            y = 350  # Âõ∫ÂÆöÂú®Â∫ïÈÉ®
            self.canvas.create_text(
                x, y, text='üåø',
                font=('Comic Sans MS', 12),
                fill='#228B22',
                tags='decoration'
            )

    def cancel_all_timers(self):
        """ÂèñÊ∂àÊâÄÊúâÂÆöÊó∂‰ªªÂä°"""
        for timer_id in self._active_timers:
            try:
                self.after_cancel(timer_id)
            except:
                pass
        self._active_timers = []
        
        if self.jellyfish_manager:
            self.jellyfish_manager.stop_animations()

    def return_to_map(self):
        if messagebox.askyesno("Confirm", "Exit current level? Progress will be lost."):
            self.cancel_all_timers()
            self._game_active = False
            self.controller.show_frame('PlayerInfoMapPage')

    def reset_game(self):
        self.cancel_all_timers()
        self._game_active = True
        self.question_count = 0
        self.score = 0
        self.lives = 3
        
        # ËÆæÁΩÆËÉåÊôØÈ¢úËâ≤
        self.bg_color = BACKGROUND_COLORS.get(self.controller.selected_difficulty, 'white')
        self.config(bg=self.bg_color)
        self.question_label.config(bg=self.bg_color)
        self.feedback_label.config(bg=self.bg_color)
        
        # ÂàùÂßãÂåñÊ∞¥ÊØçÁÆ°ÁêÜÂô®
        self.jellyfish_manager = JellyfishManager(self.canvas, self.controller.selected_difficulty)
        
        # ÂàùÂßãÂåñÈóÆÈ¢òÁîüÊàêÂô®
        self.pb = ProblemBank(self.controller.selected_difficulty)
        
        # Êõ¥Êñ∞ÁîüÂëΩÂÄºÊòæÁ§∫
        for i, label in enumerate(self.lives_labels):
            label.config(state='normal' if i < self.lives else 'disabled')
    
        # ÂºÄÂßãÊ∏∏Êàè
        self.next_question()
        return True

    def update_status(self):
        """Êõ¥Êñ∞Áä∂ÊÄÅÊòæÁ§∫"""
        self.score_label.config(text=f'Score: {self.score}')
        
        for i, label in enumerate(self.lives_labels):
            label.config(state='normal' if i < self.lives else 'disabled')
        
        self.counter_label.config(text=f'Question: {self.question_count}/{QUESTIONS_PER_GAME}')

    def next_question(self):
        """Âä†ËΩΩ‰∏ã‰∏ÄÈ¢ò"""
        if not self._game_active:
            return
            
        if self.question_count >= QUESTIONS_PER_GAME:
            self.game_completed()
            return
            
        self.question_count += 1
        
        # ÈáçÁΩÆÁ≠îÊ°àÊ£ÄÊü•Áä∂ÊÄÅ - Èò≤Ê≠¢ÈáçÂ§çÁÇπÂáª
        self._answer_checked = False
        
        # ÂèñÊ∂à‰πãÂâçÁöÑÂä®ÁîªÂíåËÆ°Êó∂Âô®
        self.cancel_all_timers()
        
        problem, answer, options = self.pb.create_problem()
        self.correct_answer = answer
        self.options = options
        
        # Êõ¥Êñ∞UI
        level_name = LEVEL_NAMES.get(self.controller.selected_difficulty, self.controller.selected_difficulty)
        self.question_label.config(text=f"{level_name}\n\n{problem}")
        self.feedback_label.config(text='')
        self.update_status()
        
        # ÂàõÂª∫Ê∞¥ÊØç
        self.create_jellyfish(options)
        
        # ÂºÄÂßãËÆ°Êó∂Âô®
        self.time_left = TIME_PER_QUESTION
        self.timer_label.config(text=f'Time: {self.time_left}s')
        self.start_timer()
    
    def start_timer(self):
        """ÂêØÂä®ËÆ°Êó∂Âô®"""
        if not self._game_active:
            return
            
        self.update_timer()

    def update_timer(self):
        """Êõ¥Êñ∞ËÆ°Êó∂Âô®"""
        if not self._game_active or not self.winfo_ismapped():
            return
        
        if self.time_left <= 0:
            self.handle_timeout()
            return
        
        self.time_left -= 1
        self.timer_label.config(text=f'Time: {self.time_left}s')
        
        if self._active_timers:
            self.after_cancel(self._active_timers[0])
        
        timer_id = self.after(1000, self.update_timer)
        self._active_timers = [timer_id]

    def handle_timeout(self):
        """Â§ÑÁêÜË∂ÖÊó∂"""
        if not self._game_active:
            return
            
        self.controller.sound_manager.play_wrong()
        self.lives -= 1
        self.feedback_label.config(text='Time up!', fg='red')
        self.update_status()
        
        # Á¶ÅÁî®ÊâÄÊúâÊ∞¥ÊØçÁÇπÂáª
        self.disable_jellyfish()
        
        if self.lives <= 0:
            self.after(1500, self.game_over)
        else:
            self.after(1500, self.next_question)

    def create_jellyfish(self, options):
        """‰ΩøÁî®Ê∞¥ÊØçÁÆ°ÁêÜÂô®ÂàõÂª∫Ê∞¥ÊØç"""
        self.jellyfish = self.jellyfish_manager.create_jellyfish(options)
        
        # ÁªëÂÆöÁÇπÂáª‰∫ã‰ª∂ - Ê∑ªÂä†ÊåâÂéãÂèçÈ¶à
        for i in range(len(self.jellyfish)):
            # ÁªëÂÆöÊåâÂéã‰∫ã‰ª∂
            self.canvas.tag_bind(f'jelly_{i}', '<ButtonPress-1>', 
                                lambda e, idx=i: self.jellyfish_manager.press_jellyfish(idx))
            
            # ÁªëÂÆöÈáäÊîæ‰∫ã‰ª∂
            self.canvas.tag_bind(f'jelly_{i}', '<ButtonRelease-1>', 
                                lambda e, idx=i, opt=options[i]: self.handle_jellyfish_release(idx, opt))
        
        # ÂºÄÂßãÂä®Áîª
        self.jellyfish_manager.animate()
    
    def handle_jellyfish_release(self, jelly_index, option):
        """Â§ÑÁêÜÊ∞¥ÊØçÈáäÊîæ‰∫ã‰ª∂"""
        # ÈáäÊîæÊåâÂéãÊïàÊûú
        self.jellyfish_manager.release_jellyfish(jelly_index)
        # Ê£ÄÊü•Á≠îÊ°à
        self.check_answer(option)
    
    def disable_jellyfish(self):
        """Á¶ÅÁî®ÊâÄÊúâÊ∞¥ÊØçÁÇπÂáª"""
        if self.jellyfish_manager:
            self.jellyfish_manager.disable_interaction()

    def check_answer(self, selected):
        """Ê£ÄÊü•Á≠îÊ°à"""
        # Èò≤Ê≠¢ÈáçÂ§çÁÇπÂáª
        if hasattr(self, '_answer_checked') and self._answer_checked:
            return
        
        self._answer_checked = True
        self.disable_jellyfish()
        
        if isinstance(self.correct_answer, tuple):
            try:
                parts = selected.split(',')
                if len(parts) != 2:
                    correct = False
                else:
                    selected_tuple = (float(parts[0]), float(parts[1]))
                    correct = (selected_tuple == self.correct_answer or
                              (selected_tuple[1], selected_tuple[0]) == self.correct_answer)
            except:
                correct = False
        else:
            try:
                correct = abs(float(selected) - float(self.correct_answer)) < 0.01
            except:
                correct = False
        
        if correct:
            self.handle_correct()
        else:
            self.handle_incorrect()

    def handle_correct(self):
        """Â§ÑÁêÜÊ≠£Á°ÆÁ≠îÊ°à"""
        self.controller.sound_manager.play_correct()
        
        difficulty = getattr(self.controller, 'selected_difficulty', 'Easy')
        points = LEVEL_POINTS.get(difficulty, 10)
        
        self.score += points
        self.feedback_label.config(text=f'+{points} points! Correct!', fg='green')
        self.update_status()
        
        self.after(1500, self.next_question)

    def handle_incorrect(self):
        """Â§ÑÁêÜÈîôËØØÁ≠îÊ°à"""
        self.controller.sound_manager.play_wrong()
        self.lives -= 1
        
        # Áî®Êà∑ÂèãÂ•ΩÁöÑÈîôËØØÊ∂àÊÅØ
        incorrect_messages = [
            "Oops! That's not quite right. Keep trying! üí™",
            "Not this time, but you're learning! üåü",
            "Close! Don't give up, you've got this! ‚ú®",
            "That's okay! Every mistake is a learning opportunity! üéØ"
        ]
        
        import random
        message = random.choice(incorrect_messages)
        self.feedback_label.config(text=message, fg='orange')
        self.update_status()
        
        if self.lives <= 0:
            self.after(1500, self.game_over)
        else:
            self.after(1500, self.next_question)

    def save_and_show_leaderboard(self):
        """‰øùÂ≠òÂàÜÊï∞Âπ∂ÊòæÁ§∫ÊéíË°åÊ¶ú"""
        player_name = getattr(self.controller, 'player_name', 'Player')
        difficulty = getattr(self.controller, 'selected_difficulty', 'Easy')
        
        # ÂÆûÈôÖ‰øùÂ≠òÂàÜÊï∞Âà∞Êñá‰ª∂
        score_manager = ScoreManager()
        score_manager.save_result(player_name, self.score, difficulty)
        
        # ‰øùÂ≠òÁªìÊûúÂà∞ÊéßÂà∂Âô®Áî®‰∫éÈ´ò‰∫ÆÊòæÁ§∫
        self.controller.last_score = {
            'player': player_name,
            'score': self.score,
            'difficulty': difficulty
        }
        
        self.controller.show_frame('LeaderboardPage')

    def game_completed(self):
        """Ê∏∏ÊàèÂÆåÊàê"""
        self._game_active = False
        self.cancel_all_timers()
        
        player_name = getattr(self.controller, 'player_name', 'Player')
        difficulty = getattr(self.controller, 'selected_difficulty', 'Easy')
        
        # Áî®Êà∑ÂèãÂ•ΩÁöÑÂÆåÊàêÊ∂àÊÅØ
        completion_messages = [
            f"üéâ Amazing job, {player_name}! You're a math superstar! üåü",
            f"üèÜ Fantastic work! You've conquered the {difficulty} challenge!",
            f"‚ú® Incredible! You've mastered the {difficulty} level!",
            f"üéä Outstanding performance! You're ready for the next challenge!"
        ]
        
        import random
        message = random.choice(completion_messages)
        
        # ‰ΩøÁî®Ëá™ÂÆö‰πâÂØπËØùÊ°ÜÊèê‰æõÊõ¥Â§öÈÄâÈ°π
        from tkinter import simpledialog
        
        # ÂàõÂª∫Ëá™ÂÆö‰πâÂØπËØùÊ°Ü
        dialog = tk.Toplevel()
        dialog.title("üéâ Level Complete! üéâ")
        dialog.geometry("500x300")
        dialog.configure(bg='#E8F4FD')
        dialog.resizable(False, False)
        
        # Â±Ö‰∏≠ÊòæÁ§∫
        dialog.transient(self)
        dialog.grab_set()
        
        # ÂÜÖÂÆπ
        content_frame = tk.Frame(dialog, bg='#E8F4FD')
        content_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        tk.Label(
            content_frame,
            text=message,
            font=('Comic Sans MS', 14, 'bold'),
            bg='#E8F4FD',
            fg='#2C3E50',
            wraplength=450
        ).pack(pady=10)
        
        tk.Label(
            content_frame,
            text=f"üéØ Final Score: {self.score} points\nüéÆ Difficulty: {difficulty}",
            font=('Comic Sans MS', 12),
            bg='#E8F4FD',
            fg='#006994'
        ).pack(pady=10)
        
        # ÊåâÈíÆÊ°ÜÊû∂
        button_frame = tk.Frame(content_frame, bg='#E8F4FD')
        button_frame.pack(pady=20)
        
        play_again_var = tk.StringVar(value="")
        
        def on_play_again():
            play_again_var.set("play_again")
            dialog.destroy()
        
        def on_back_menu():
            play_again_var.set("back_menu")
            dialog.destroy()
        
        def on_leaderboard():
            play_again_var.set("leaderboard")
            dialog.destroy()
        
        tk.Button(
            button_frame,
            text="üéÆ Play Again (Same Difficulty)",
            font=('Comic Sans MS', 12, 'bold'),
            bg='#4CAF50',
            fg='white',
            padx=15,
            pady=8,
            command=on_play_again
        ).pack(side='left', padx=5)
        
        tk.Button(
            button_frame,
            text="üè† Back to Menu",
                font=('Comic Sans MS', 12, 'bold'),
            bg='#FF9800',
                fg='white',
            padx=15,
            pady=8,
            command=on_back_menu
        ).pack(side='left', padx=5)
        
        tk.Button(
            button_frame,
            text="üèÜ View Leaderboard",
            font=('Comic Sans MS', 12, 'bold'),
            bg='#2196F3',
            fg='white',
            padx=15,
            pady=8,
            command=on_leaderboard
        ).pack(side='left', padx=5)
        
        # Á≠âÂæÖÁî®Êà∑ÈÄâÊã©
        dialog.wait_window()
        result = play_again_var.get()
        
        if result == "play_again":
            # Áõ¥Êé•ÈáçÊñ∞ÂºÄÂßãÁõ∏ÂêåÈöæÂ∫¶ÁöÑÊ∏∏Êàè
            self.reset_game()
            self.controller.show_frame('GamePage')
        elif result == "back_menu":
            # ËøîÂõûËèúÂçïÂπ∂ÈáçÁΩÆÁé©ÂÆ∂‰ø°ÊÅØ
            self.reset_game()
            player_info_page = self.controller.page_frames['PlayerInfoMapPage']
            player_info_page.reset_player_info()
            self.controller.show_frame('PlayerInfoMapPage')
        else:  # leaderboard
            # ÊòæÁ§∫ÊéíË°åÊ¶ú
            self.save_and_show_leaderboard()

    def game_over(self):
        """Ê∏∏ÊàèÁªìÊùü"""
        self._game_active = False
        self.cancel_all_timers()
        
        player_name = getattr(self.controller, 'player_name', 'Player')
        
        # Áî®Êà∑ÂèãÂ•ΩÁöÑÊ∏∏ÊàèÁªìÊùüÊ∂àÊÅØ
        game_over_messages = [
            f"üí™ Don't worry, {player_name}! Every great mathematician started somewhere!",
            f"üåü Keep practicing, {player_name}! You're getting better with each try!",
            f"üéØ Nice effort, {player_name}! Math is a journey, not a destination!",
            f"‚ú® Great attempt, {player_name}! Learning from mistakes makes you stronger!"
        ]
        
        import random
        message = random.choice(game_over_messages)
        
        # Ê†πÊçÆÂΩìÂâçÈöæÂ∫¶Êèê‰æõÂêàÈÄÇÁöÑÂª∫ËÆÆ
        current_difficulty = getattr(self.controller, 'selected_difficulty', 'Easy')
        if current_difficulty == 'Easy':
            tip = "üí° Tip: Practice makes perfect! Try again to improve your score!"
        elif current_difficulty == 'Medium':
            tip = "üí° Tip: You're doing great! Try the Easy level to build confidence, or try Medium again!"
        else:  # Hard
            tip = "üí° Tip: Hard level is challenging! Try Medium or Easy to practice first!"
        
        result = messagebox.askyesno(
            "üéÆ Game Over - But Don't Give Up! üéÆ",
            f"{message}\n\n"
            f"üéØ Final Score: {self.score} points\n"
            f"üéÆ Difficulty: {current_difficulty}\n"
            f"{tip}\n\n"
            f"Would you like to try again?"
        )
        
        if result:
            # Áõ¥Êé•ÈáçÊñ∞ÂºÄÂßãÁõ∏ÂêåÈöæÂ∫¶ÁöÑÊ∏∏Êàè
            self.reset_game()
            self.controller.show_frame('GamePage')
        else:
            # ÊòæÁ§∫ÊéíË°åÊ¶ú
            self.save_and_show_leaderboard()

game_objects file:

import tkinter as tk
import random
import math
import json
import time
import os
from utils import ScoreManager as DataManager  # ÂØºÂÖ•ÂàÜÊï∞ÁÆ°ÁêÜÂô®

class JellyfishManager:
    """ÁÆ°ÁêÜÊ∞¥ÊØçËÆæÂÆöÂíåË°å‰∏∫ÁöÑÁ±ª - ‰ΩøÁî®ÁúüÂÆûÊ∞¥ÊØçÂõæÁâá"""
    SPEEDS = {'Easy': 7, 'Medium': 1.9, 'Hard': 1.7}  # Ê∞¥ÊØçÈÄüÂ∫¶ËÆæÁΩÆ
    
    def __init__(self, canvas, difficulty):
        self.canvas = canvas
        self.difficulty = difficulty
        self.jellyfish = []
        self.active_animations = []
        self.jellyfish_images = self._load_jellyfish_images()
    
    def _load_jellyfish_images(self):
        """Âä†ËΩΩÊ∞¥ÊØçÂõæÁâáËµÑÊ∫ê"""
        try:
            # Â∞ùËØïÂä†ËΩΩÊ∞¥ÊØçPNGÂõæÁâá
            img = tk.PhotoImage(file='assets/Images/jellyfish.png')
            return {
                'main': img.subsample(3, 3),  # ‰∏ªÊ∞¥ÊØçÂõæÁâá - ËæÉÂ∞èÂ∞∫ÂØ∏
                'small': img.subsample(4, 4),  # Êõ¥Â∞èÁöÑÊ∞¥ÊØçÂõæÁâá
                'glow': img.subsample(3, 3)    # ÂèëÂÖâÊïàÊûúÂõæÁâá
            }
        except Exception as e:
            print(f"Êó†Ê≥ïÂä†ËΩΩÊ∞¥ÊØçÂõæÁâá: {e}")
            return None
    
    def create_jellyfish(self, options):
        """ÂàõÂª∫ÁúüÂÆûÊ∞¥ÊØçÂØπË±° - ‰ΩøÁî®PNGÂõæÁâá"""
        self.canvas.delete('all')
        self.jellyfish = []
        positions = self._calculate_positions(len(options))
        
        for i, option in enumerate(options):
            x, y = positions[i]
            
            # ÂàõÂª∫Ê∞¥ÊØç‰∏ª‰Ωì - ‰ΩøÁî®ÁúüÂÆûÊ∞¥ÊØçÂõæÁâá
            if self.jellyfish_images:
                jelly_id = self.canvas.create_image(
                    x, y-25,  # Ê∞¥ÊØçÂõæÁâá‰ΩçÁΩÆ - Á®çÂæÆ‰∏äÁßª
                    image=self.jellyfish_images['main'],
                    tags=('jellyfish', 'clickable', f'jelly_{i}')
                )
            else:
                # Â§áÁî®ÊñπÊ°àÔºöÂàõÂª∫Êõ¥ÁúüÂÆûÁöÑÊ∞¥ÊØçÂΩ¢Áä∂
                jelly_id = self.canvas.create_oval(
                    x-20, y-20, x+20, y+20,
                    fill='#FFE4E1',  # Êõ¥ÊüîÂíåÁöÑÁ≤âËâ≤
                    outline='#FFB6C1', width=2,  # Êõ¥ÊüîÂíåÁöÑËΩÆÂªì
                    tags=('jellyfish', 'clickable', f'jelly_{i}')
                )
                
                # Ê∑ªÂä†Ê∞¥ÊØçËß¶È°ªÊïàÊûú
                for j in range(3):
                    tentacle_x = x + random.randint(-15, 15)
                    tentacle_y = y + 20 + j * 8
                    self.canvas.create_line(
                        x, y+15, tentacle_x, tentacle_y,
                        fill='#FFB6C1', width=2,
                        tags=('jellyfish', 'tentacle', f'jelly_{i}')
                    )
            
            # ÂàõÂª∫Á≠îÊ°àÊ∞îÊ≥° - Êµ∑ÁªµÂÆùÂÆùÈ£éÊ†ºÔºåÊõ¥Â∞èÊõ¥Á≤æËá¥
            bubble = self.canvas.create_oval(
                x-30, y+15, x+30, y+70,  # Ê∞îÊ≥°Âú®Ê∞¥ÊØç‰∏ãÊñπÔºåÊõ¥Â∞è
                fill='#F4E4BC',  # Êµ∑ÁªµÂÆùÂÆùËÇ§Ëâ≤
                outline='#DAA520', width=2,  # ÈáëËâ≤ËæπÊ°Ü
                tags=('jellyfish', 'clickable', 'bubble', f'jelly_{i}')
            )
            
            # Ê∑ªÂä†Á≠îÊ°àÊñáÊú¨ - Êõ¥Ê∏ÖÊô∞ÊòìËØª
            text_id = self.canvas.create_text(
                x, y+42,  # ÊñáÊú¨Âú®Ê∞îÊ≥°‰∏≠Â§Æ
                text=option, 
                font=('Arial', 14, 'bold'),  # Á®çÂæÆÂ∞è‰∏ÄÁÇπÁöÑÂ≠ó‰Ωì
                fill='#654321',  # Ê∑±Ê£ïËâ≤ÊñáÂ≠ó
                tags=('jellyfish', 'clickable', 'bubble_text', f'jelly_{i}')
            )
            
            # Ê∑ªÂä†ÊñáÂ≠óÈò¥ÂΩ± - Â¢ûÂº∫ÂèØËØªÊÄß
            shadow_id = self.canvas.create_text(
                x+1, y+43,  # Èò¥ÂΩ±ÂÅèÁßª
                text=option, 
                font=('Arial', 14, 'bold'),
                fill='#8B4513',  # Ê∑±Ê£ïËâ≤Èò¥ÂΩ±
                tags=('jellyfish', 'text_shadow', f'jelly_{i}')
            )
            
            # ËÆæÁΩÆÁßªÂä®Â±ûÊÄß
            angle = random.uniform(0, 2 * math.pi)
            speed = self.SPEEDS.get(self.difficulty, 1.0)
            dx = math.cos(angle) * speed
            dy = math.sin(angle) * speed
            
            self.jellyfish.append({
                'jelly_id': jelly_id,
                'bubble': bubble,
                'text': text_id,
                'shadow': shadow_id,
                'dx': dx,
                'dy': dy,
                'x': x,
                'y': y,
                'animation_offset': random.uniform(0, 2 * math.pi),  # Âä®ÁîªÂÅèÁßª
                'pressed': False,  # ÊåâÂéãÁä∂ÊÄÅ
                'original_y': y  # ÂéüÂßãY‰ΩçÁΩÆÁî®‰∫éÊåâÂéãÊïàÊûú
            })
        
        return self.jellyfish
    
    def animate(self):
        """Âä®ÁîªÊ∞¥ÊØçËøêÂä® - Ëá™ÁÑ∂ÊµÅÁïÖÔºåÈÅøÂÖçÈáçÂè†ÂíåËæπÁïåÈóÆÈ¢ò"""
        width = self.canvas.winfo_width()
        height = self.canvas.winfo_height()
        
        if width < 100:
            width = 700
        if height < 100:
            height = 400
        
        # Â¢ûÂä†ËæπÁïåÁ©∫Èó¥ÔºåÈÅøÂÖçÊ∞¥ÊØçË¢´ÂàáÂâ≤
        boundary_height = int(height * 0.75)  # ÂáèÂ∞ëÊ¥ªÂä®ËåÉÂõ¥ÔºåÁïôÊõ¥Â§öÂ∫ïÈÉ®Á©∫Èó¥
        boundary_width = width - 80  # Â∑¶Âè≥ÂêÑÁïô40ÂÉèÁ¥†Á©∫Èó¥
        
        current_time = time.time()
        
        for jelly in self.jellyfish:
            # ËÆ°ÁÆóÊ≥¢Âä®ÊïàÊûú - ‰ΩøÁî®Âä®ÁîªÂÅèÁßªÈÅøÂÖçÂêåÊ≠•
            wave_x = math.sin(current_time * 0.8 + jelly['animation_offset']) * 2
            wave_y = math.cos(current_time * 1.2 + jelly['animation_offset']) * 2
            
            # Êõ¥Êñ∞‰ΩçÁΩÆ - Âü∫Á°ÄÁßªÂä® + Ê≥¢Âä®
            new_x = jelly['x'] + jelly['dx'] + wave_x
            new_y = jelly['y'] + jelly['dy'] + wave_y
            
            # ËæπÁïåÊ£ÄÊµã - Âπ≥ÊªëÂèçÂºπÔºåÁ°Æ‰øùÊ∞¥ÊØçÂÆåÂÖ®ÂèØËßÅ
            if new_x < 60:  # Â¢ûÂä†Â∑¶ËæπË∑ù
                new_x = 60
                jelly['dx'] = abs(jelly['dx']) * 0.9  # Âπ≥ÊªëÂèçÂºπ
            elif new_x > boundary_width:
                new_x = boundary_width
                jelly['dx'] = -abs(jelly['dx']) * 0.9  # Âπ≥ÊªëÂèçÂºπ
                
            if new_y < 60:  # Â¢ûÂä†‰∏äËæπË∑ù
                new_y = 60
                jelly['dy'] = abs(jelly['dy']) * 0.9  # Âπ≥ÊªëÂèçÂºπ
            elif new_y > boundary_height:
                new_y = boundary_height
                jelly['dy'] = -abs(jelly['dy']) * 0.9  # Âπ≥ÊªëÂèçÂºπ
            
            # Êõ¥Êñ∞Ê∞¥ÊØçÂõæÁâá‰ΩçÁΩÆ
            self.canvas.coords(jelly['jelly_id'], new_x, new_y-25)
            
            # Êõ¥Êñ∞Ê∞îÊ≥°‰ΩçÁΩÆ
            self.canvas.coords(jelly['bubble'], 
                              new_x-30, new_y+15, 
                              new_x+30, new_y+70)
            
            # Êõ¥Êñ∞ÊñáÊú¨‰ΩçÁΩÆ
            self.canvas.coords(jelly['text'], new_x, new_y+42)
            self.canvas.coords(jelly['shadow'], new_x+1, new_y+43)
            
            # Á¢∞ÊíûÊ£ÄÊµã - ÈÅøÂÖçÊ∞¥ÊØçÈáçÂè†
            min_distance = 100  # ÊúÄÂ∞èË∑ùÁ¶ª
            for other_jelly in self.jellyfish:
                if other_jelly != jelly:
                    dx = new_x - other_jelly['x']
                    dy = new_y - other_jelly['y']
                    distance = math.sqrt(dx*dx + dy*dy)
                    
                    if distance < min_distance:
                        # Â¶ÇÊûúÂ§™ËøëÔºåÁ®çÂæÆÊé®ÂºÄ
                        if distance > 0:
                            push_x = (dx / distance) * (min_distance - distance) * 0.5
                            push_y = (dy / distance) * (min_distance - distance) * 0.5
                            new_x += push_x
                            new_y += push_y
                            
                            # Á°Æ‰øùÊé®ÂºÄÁöÑË∑ùÁ¶ª‰ªçÂú®ËæπÁïåÂÜÖ
                            new_x = max(60, min(boundary_width, new_x))
                            new_y = max(60, min(boundary_height, new_y))
            
            # ‰øùÂ≠òÊñ∞‰ΩçÁΩÆ
            jelly['x'] = new_x
            jelly['y'] = new_y
        
        # ÁªßÁª≠Âä®ÁîªÂæ™ÁéØ - 30fps
        anim_id = self.canvas.after(30, self.animate)
        self.active_animations.append(anim_id)
    
    def stop_animations(self):
        """ÂÅúÊ≠¢ÊâÄÊúâÂä®Áîª"""
        for anim_id in self.active_animations:
            try:
                self.canvas.after_cancel(anim_id)
            except:
                pass
        self.active_animations = []
    
    def disable_interaction(self):
        """Á¶ÅÁî®ÊâÄÊúâÊ∞¥ÊØç‰∫§‰∫í"""
        self.canvas.tag_unbind('clickable', '<Button-1>')
        self.canvas.tag_unbind('clickable', '<ButtonPress-1>')
        self.canvas.tag_unbind('clickable', '<ButtonRelease-1>')
    
    def press_jellyfish(self, jelly_index):
        """ÊåâÂéãÊ∞¥ÊØçÊïàÊûú - ËßÜËßâÂèçÈ¶à"""
        if 0 <= jelly_index < len(self.jellyfish):
            jelly = self.jellyfish[jelly_index]
            if not jelly['pressed']:
                jelly['pressed'] = True
                # ÁßªÂä®Ê∞¥ÊØçÂêë‰∏ãÔºåÊ®°ÊãüÊåâÂéãÊïàÊûú - Êõ¥ÊòéÊòæÁöÑÁßªÂä®
                self.canvas.coords(jelly['jelly_id'], jelly['x'], jelly['y']-20)
                self.canvas.coords(jelly['bubble'], 
                                 jelly['x']-30, jelly['y']+15, 
                                 jelly['x']+30, jelly['y']+70)
                self.canvas.coords(jelly['text'], jelly['x'], jelly['y']+42)
                self.canvas.coords(jelly['shadow'], jelly['x']+1, jelly['y']+43)
                
                # Ê∑ªÂä†ÂèëÂÖâÊïàÊûú - Êõ¥ÊòéÊòæÁöÑÈ¢úËâ≤ÂèòÂåñ
                self.canvas.itemconfig(jelly['bubble'], fill='#FFD700', outline='#FFA500', width=4)
                
                # Ê∑ªÂä†ÊñáÊú¨È´ò‰∫ÆÊïàÊûú
                self.canvas.itemconfig(jelly['text'], fill='#8B0000', font=('Arial', 16, 'bold'))
                self.canvas.itemconfig(jelly['shadow'], fill='#4B0082', font=('Arial', 16, 'bold'))
                
                # Ê∑ªÂä†Ê∞¥ÊØçÂõæÁâáÁº©ÊîæÊïàÊûúÔºàÂ¶ÇÊûú‰ΩøÁî®ÂõæÁâáÔºâ
                if self.jellyfish_images:
                    # Á®çÂæÆÊîæÂ§ßÊ∞¥ÊØçÂõæÁâá
                    self.canvas.scale(jelly['jelly_id'], jelly['x'], jelly['y']-20, 1.1, 1.1)
    
    def release_jellyfish(self, jelly_index):
        """ÈáäÊîæÊ∞¥ÊØçÊïàÊûú - ÊÅ¢Â§çÂéü‰ΩçÁΩÆ"""
        if 0 <= jelly_index < len(self.jellyfish):
            jelly = self.jellyfish[jelly_index]
            if jelly['pressed']:
                jelly['pressed'] = False
                # ÊÅ¢Â§çÊ∞¥ÊØçÂà∞Âéü‰ΩçÁΩÆ
                self.canvas.coords(jelly['jelly_id'], jelly['x'], jelly['y']-25)
                self.canvas.coords(jelly['bubble'], 
                                 jelly['x']-30, jelly['y']+15, 
                                 jelly['x']+30, jelly['y']+70)
                self.canvas.coords(jelly['text'], jelly['x'], jelly['y']+42)
                self.canvas.coords(jelly['shadow'], jelly['x']+1, jelly['y']+43)
                
                # ÊÅ¢Â§çÊ∞îÊ≥°È¢úËâ≤
                self.canvas.itemconfig(jelly['bubble'], fill='#F4E4BC', outline='#DAA520', width=2)
                
                # ÊÅ¢Â§çÊñáÊú¨Ê†∑Âºè
                self.canvas.itemconfig(jelly['text'], fill='#654321', font=('Arial', 14, 'bold'))
                self.canvas.itemconfig(jelly['shadow'], fill='#8B4513', font=('Arial', 14, 'bold'))
                
                # ÊÅ¢Â§çÊ∞¥ÊØçÂõæÁâáÁº©ÊîæÔºàÂ¶ÇÊûú‰ΩøÁî®ÂõæÁâáÔºâ
                if self.jellyfish_images:
                    # ÊÅ¢Â§çÊ∞¥ÊØçÂõæÁâáÂ§ßÂ∞è
                    self.canvas.scale(jelly['jelly_id'], jelly['x'], jelly['y']-25, 1.0, 1.0)
    
    def _calculate_positions(self, count):
        """ËÆ°ÁÆóÊ∞¥ÊØçÂàùÂßã‰ΩçÁΩÆ - ÈÅøÂÖçÈáçÂè†"""
        width = max(self.canvas.winfo_width(), 700)
        height = min(max(self.canvas.winfo_height(), 400), 400) * 0.7
    
        if count == 1:
            return [(width // 2, height // 2)]

        positions = []
        center_x, center_y = width // 2, height // 2
        
        # Ê†πÊçÆÊ∞¥ÊØçÊï∞ÈáèË∞ÉÊï¥ÂçäÂæÑÔºåÁ°Æ‰øùË∂≥Â§üÈó¥Ë∑ù
        if count == 2:
            radius = min(width, height) * 0.25  # 2‰∏™Ê∞¥ÊØçÊó∂‰ΩøÁî®ËæÉÂ∞èÂçäÂæÑ
        elif count == 3:
            radius = min(width, height) * 0.3   # 3‰∏™Ê∞¥ÊØçÊó∂‰ΩøÁî®‰∏≠Á≠âÂçäÂæÑ
        else:
            radius = min(width, height) * 0.35  # 4‰∏™Ê∞¥ÊØçÊó∂‰ΩøÁî®ËæÉÂ§ßÂçäÂæÑ
    
        for i in range(count):
            angle = 2 * math.pi * i / count
            x = center_x + radius * math.cos(angle)
            y = center_y + radius * math.sin(angle)
            
            # Ê∑ªÂä†ÈöèÊú∫ÂÅèÁßªÔºåÈÅøÂÖçÂÆåÂÖ®ÈáçÂè†
            import random
            x += random.randint(-20, 20)
            y += random.randint(-20, 20)
        
            # Á°Æ‰øùÂú®ÂÆâÂÖ®ËæπÁïåÂÜÖ
            x = max(80, min(width - 80, x))
            y = max(80, min(height - 80, y))
        
            positions.append((x, y))
    
        return positions


# ÁßªÈô§CharacterManagerÁ±ª - ‰∏çÂÜçÈúÄË¶ÅËßíËâ≤ÈÄâÊã©ÂäüËÉΩ


class LeaderboardPage(tk.Frame):
    """ÊéíË°åÊ¶úÈ°µÈù¢"""
    def __init__(self, parent, controller):
        super().__init__(parent, bg='#f0f8ff')
        self.controller = controller
        self._create_widgets()
    
    def _create_widgets(self):
        """ÂàõÂª∫UIÂÖÉÁ¥†"""
        # ‰∏ªÊ°ÜÊû∂ - Ê∏êÂèòËÉåÊôØÊïàÊûú
        self.config(bg='#E8F4FD')  # Êµ∑Ê¥ãËìùËÉåÊôØ
        main_frame = tk.Frame(self, bg='#E8F4FD')
        main_frame.pack(fill='both', expand=True, padx=15, pady=15)
        
        # Ê∑ªÂä†Ë£ÖÈ•∞ÊÄßËæπÊ°Ü
        border_frame = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        border_frame.pack(fill='both', expand=True, padx=5, pady=5)
        
        # ÂÜÖÂÆπÊ°ÜÊû∂
        content_frame = tk.Frame(border_frame, bg='#F0F8FF')
        content_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Ê†áÈ¢òÊ°ÜÊû∂
        title_frame = tk.Frame(content_frame, bg='#F0F8FF')
        title_frame.pack(pady=10)
        
        tk.Label(
            title_frame, 
            text='üèÜ Bikini Bottom Hall of Fame',
            font=('Comic Sans MS', 24, 'bold'),
            bg='#F0F8FF', 
            fg='#006994'
        ).pack(pady=10)
        
        self.leaderboard_frame = tk.Frame(content_frame, bg='#f0f8ff', bd=3, relief='groove')
        self.leaderboard_frame.pack(side='top', pady=10, fill='both', expand=True)
        
        menu_btn = tk.Button(
            content_frame, 
            text='üè† Main Menu', 
            font=('Comic Sans MS', 14, 'bold'),
            bg='#FFD700', 
            fg='#2C3E50',
            padx=15,
            pady=8,
            relief='raised',
            bd=2,
            command=lambda: self.controller.show_frame('StartPage')
        )
        menu_btn.pack(side='bottom', pady=10)
        
        self.refresh()

    def refresh(self):
        """Âà∑Êñ∞ÊéíË°åÊ¶úÊòæÁ§∫"""
        for widget in self.leaderboard_frame.winfo_children():
            widget.destroy()
        
        header = tk.Frame(self.leaderboard_frame, bg='#5a9')
        header.pack(fill='x', pady=(0, 5))
        
        headers = ['Rank', 'Name', 'Score', 'Difficulty']
        widths = [8, 20, 10, 15]
        
        for i, h in enumerate(headers):
            tk.Label(
                header, 
                text=h, 
                font=('Comic Sans MS', 12, 'bold'),
                bg='#5a9', 
                fg='white',
                width=widths[i]
            ).grid(row=0, column=i, padx=2, sticky='ew')
        
        scores = DataManager().get_records()
        
        if not scores:
            no_scores = tk.Label(
                self.leaderboard_frame,
                text='No scores yet! Be the first to play!',
                font=('Comic Sans MS', 16),
                bg='#f0f8ff',
                pady=50
            )
            no_scores.pack(fill='both', expand=True)
            return
        
        scores_container = tk.Canvas(self.leaderboard_frame, bg='#f0f8ff', highlightthickness=0)
        scrollbar = tk.Scrollbar(self.leaderboard_frame, orient='vertical', command=scores_container.yview)
        scrollable_frame = tk.Frame(scores_container, bg='#f0f8ff')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: scores_container.configure(scrollregion=scores_container.bbox("all"))
        )
        scores_container.create_window((0, 0), window=scrollable_frame, anchor="nw")
        scores_container.configure(yscrollcommand=scrollbar.set)
        
        scores_container.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
        
        highlight_index = -1
        if hasattr(self.controller, 'last_score') and self.controller.last_score is not None:
            player_score = self.controller.last_score
            
            for i, score in enumerate(scores):
                score_player = score.get('player', score.get('name', 'Unknown'))
                player_name = player_score.get('player', player_score.get('name', 'Player'))
                
                score_value = score.get('score', 0)
                player_value = player_score.get('score', 0)
                
                score_difficulty = score.get('difficulty', score.get('level', 'Easy'))
                player_difficulty = player_score.get('difficulty', 'Easy')
                
                if (score_player == player_name and 
                    score_value == player_value and 
                    score_difficulty == player_difficulty):
                    highlight_index = i
                    break
        
        prev_score = None
        rank = 0
        skip = 0
        
        for i, score in enumerate(scores[:10]):
            current_score = score.get('score', 0)
            current_difficulty = score.get('difficulty', score.get('level', 'Easy'))
            
            if prev_score is None:
                prev_score = score
                rank = 1
                skip = 0
            else:
                prev_score_value = prev_score.get('score', 0)
                prev_difficulty = prev_score.get('difficulty', prev_score.get('level', 'Easy'))
                
                if current_score != prev_score_value or current_difficulty != prev_difficulty:
                    rank += 1 + skip
                    skip = 0
                else:
                    skip += 1
            
            if i == highlight_index:
                bg_color = '#FFD700'  # ÈáëËâ≤È´ò‰∫Æ
            elif i % 2 == 0:
                bg_color = '#e6f7ff'
            else:
                bg_color = '#f0f8ff'
            
            row = tk.Frame(scrollable_frame, bg=bg_color)
            row.pack(fill='x', pady=2)
            
            tk.Label(
                row, 
                text=str(rank), 
                font=('Comic Sans MS', 12),
                bg=bg_color, 
                width=widths[0]
            ).grid(row=0, column=0)
            
            player_name = score.get('player', score.get('name', 'Unknown'))
            tk.Label(
                row, 
                text=player_name, 
                font=('Comic Sans MS', 12),
                bg=bg_color, 
                width=widths[1]
            ).grid(row=0, column=1)
            
            tk.Label(
                row, 
                text=str(score.get('score', 0)), 
                font=('Comic Sans MS', 12),
                bg=bg_color, 
                width=widths[2]
            ).grid(row=0, column=2)
            
            difficulty = score.get('difficulty', score.get('level', 'Easy'))
            tk.Label(
                row, 
                text=difficulty, 
                font=('Comic Sans MS', 12),
                bg=bg_color, 
                width=widths[3]
            ).grid(row=0, column=3)
            
            prev_score = score

utils file:

import random
import json
import os
import time

# Try to import pygame for sound effects, but don't crash if it's not available
try:
    import pygame
    pygame_works = True
except ImportError:
    pygame_works = False
    print("pygame not found - sound will be turned off")

class ProblemGenerator:
    """Makes math problems fun with SpongeBob stuff"""
    
    def __init__(self, difficulty='Easy'):
        self.difficulty = difficulty
        # Stuff from the show to make problems interesting
        self.people = ['SpongeBob', 'Patrick', 'Squidward', 'Mr. Krabs', 'Sandy']
        self.stuff = ['Krabby Patty', 'jellyfish', 'bubble', 'pineapple', 'treasure chest', 
                     'karate glove', 'kite', 'net', 'spatula', 'money']
        self.places = ['Bikini Bottom', 'Jellyfish Fields', 'Krusty Krab', 'Pineapple House', 
                         'Rock Bottom', 'Goo Lagoon', 'Chum Bucket']

    def create_problem(self):
        """Makes a math problem with SpongeBob theme and gives you choices to pick from"""
        if self.difficulty == 'Easy':
            problem, answer = self._make_easy_one()
        elif self.difficulty == 'Medium':
            problem, answer = self._make_medium_one()
        else:
            problem, answer = self._make_hard_one()
        
        choices = self._make_choices(answer)
        return problem, answer, choices

    def _make_easy_one(self):
        """Easy problems for beginners"""
        what_kind = random.choice(['math', 'counting', 'money'])
        
        if what_kind == 'math':
            return self._basic_math()
        elif what_kind == 'counting':
            return self._counting_stuff()
        else:
            return self._money_stuff()

    def _basic_math(self):
        """Simple adding, subtracting, multiplying with SpongeBob things"""
        num1 = random.randint(1, 12)
        num2 = random.randint(1, 12)
        what_to_do = random.choice(['+', '-', 'x'])
        
        if what_to_do == 'x':
            result = num1 * num2
            thing = random.choice(self.stuff)
            problem = f"SpongeBob has {num1} {thing}s. If he gets {num2} times more, how many {thing}s does he have now?"
        elif what_to_do == '+':
            result = num1 + num2
            thing1, thing2 = random.sample(self.stuff, 2)
            problem = f"Patrick found {num1} {thing1}s and {num2} {thing2}s. How many things did he find in total?"
        else:  # subtraction
            result = num1 - num2
            thing = random.choice(self.stuff)
            problem = f"Mr. Krabs had {num1} {thing}s. He sold {num2} of them. How many {thing}s does he have left?"
        
        return problem, result

    def _counting_stuff(self):
        """Counting problems with characters"""
        person = random.choice(self.people)
        thing = random.choice(self.stuff)
        how_many = random.randint(3, 15)
        
        problem = f"{person} is collecting {thing}s. He already has {how_many} {thing}s. "
        if random.choice([True, False]):
            # Adding more
            extra = random.randint(1, 8)
            result = how_many + extra
            problem += f"If he finds {extra} more {thing}s, how many {thing}s will he have?"
        else:
            # Taking some away
            less = random.randint(1, min(how_many-1, 5))
            result = how_many - less
            problem += f"If he gives away {less} {thing}s, how many {thing}s will he have left?"
        
        return problem, result

    def _money_stuff(self):
        """Money problems at the Krusty Krab"""
        cost = random.randint(2, 8)
        how_many = random.randint(1, 10)
        total = cost * how_many
        
        problem = f"A Krabby Patty costs ${cost}. If you buy {how_many} Krabby Patties, how much do you pay in total?"
        return problem, total

    def _make_medium_one(self):
        """Medium problems - a bit harder"""
        what_kind = random.choice(['equation', 'percent', 'sequence'])
        
        if what_kind == 'equation':
            return self._equation_problem()
        elif what_kind == 'percent':
            return self._percent_problem()
        else:
            return self._sequence_problem()

    def _equation_problem(self):
        """Simple equations like 2x + 3 = 11"""
        x = random.randint(2, 15)
        a = random.randint(1, 5)
        b = random.randint(1, 10)
        
        # Make sure the equation makes sense
        result = a * x + b
        person = random.choice(self.people)
        thing = random.choice(self.stuff)
        
        problem = f"{person} has {a} {thing}s. If someone gives him {b} more {thing}s, he now has {result} {thing}s. How many {thing}s did he have at first?"
        return problem, x

    def _percent_problem(self):
        """Percentage problems"""
        percent = random.choice([10, 20, 25, 50, 75])
        original = random.randint(10, 100)
        new_amount = int(original * (1 + percent/100))
        
        person = random.choice(self.people)
        thing = random.choice(self.stuff)
        
        problem = f"{person} had {original} {thing}s. After a {percent}% increase, he now has {new_amount} {thing}s. What was the original number?"
        return problem, original

    def _sequence_problem(self):
        """Find the next number in a pattern"""
        start = random.randint(1, 10)
        step = random.randint(2, 8)
        
        # Make a sequence: start, start+step, start+2*step, start+3*step, ?
        sequence = [start, start + step, start + 2*step, start + 3*step]
        answer = start + 4*step
        
        person = random.choice(self.people)
        thing = random.choice(self.stuff)
        
        problem = f"{person} is counting {thing}s: {sequence[0]}, {sequence[1]}, {sequence[2]}, {sequence[3]}, ... What comes next?"
        return problem, answer

    def _make_hard_one(self):
        """Hard problems for smart people"""
        what_kind = random.choice(['quadratic', 'system', 'geometry'])
        
        if what_kind == 'quadratic':
            return self._quadratic_problem()
        elif what_kind == 'system':
            return self._system_problem()
        else:
            return self._geometry_problem()

    def _quadratic_problem(self):
        """Quadratic equations that factor nicely"""
        # Pick nice numbers that work well together
        x1 = random.randint(2, 8)
        x2 = random.randint(2, 8)
        
        # Make sure they're different
        if x1 == x2:
            x2 = random.randint(9, 12)
        
        # (x - x1)(x - x2) = x^2 - (x1+x2)x + x1*x2
        a = 1
        b = -(x1 + x2)
        c = x1 * x2
        
        # Pick one of the roots as the answer
        answer = random.choice([x1, x2])
        
        person = random.choice(self.people)
        thing = random.choice(self.stuff)
        
        problem = f"{person} is solving: x¬≤ + {b}x + {c} = 0. One solution is x = {answer}. What's the other solution?"
        # Return the other root
        other_answer = x1 if answer == x2 else x2
        return problem, other_answer

    def _system_problem(self):
        """System of two equations"""
        # Make simple equations that are easy to solve
        x = random.randint(2, 8)
        y = random.randint(2, 8)
        
        # x + y = something, x - y = something else
        sum_xy = x + y
        diff_xy = x - y
        
        person1, person2 = random.sample(self.people, 2)
        thing1, thing2 = random.sample(self.stuff, 2)
        
        problem = f"{person1} has x {thing1}s and y {thing2}s. {person2} has the same x {thing1}s but different y {thing2}s. "
        problem += f"Together they have {sum_xy} items, but the difference is {diff_xy}. What is x?"
        
        return problem, x

    def _geometry_problem(self):
        """Simple area or perimeter problems"""
        what_kind = random.choice(['area', 'perimeter'])
        
        if what_kind == 'area':
            length = random.randint(3, 10)
            width = random.randint(3, 10)
            area = length * width
            
            person = random.choice(self.people)
            thing = random.choice(self.stuff)
            
            problem = f"{person} has a {thing} garden that is {length} feet long and {width} feet wide. What's the area in square feet?"
            return problem, area
        else:
            # Perimeter
            side = random.randint(4, 12)
            perimeter = 4 * side
            
            person = random.choice(self.people)
            thing = random.choice(self.stuff)
            
            problem = f"{person} has a square {thing} box with sides of {side} inches. What's the perimeter in inches?"
            return problem, perimeter

    def _make_choices(self, correct_answer):
        """Makes 4 choices, one correct and three wrong ones"""
        choices = [correct_answer]
        
        # Add some wrong answers that make sense
        if correct_answer > 0:
            # Common mistakes: off by 1, off by 10, double, half
            wrong1 = correct_answer + 1
            wrong2 = correct_answer + 10
            wrong3 = correct_answer * 2
            wrong4 = correct_answer // 2 if correct_answer > 1 else correct_answer + 5
            
            # Pick 3 different wrong answers
            wrong_answers = list(set([wrong1, wrong2, wrong3, wrong4]))
            wrong_answers = wrong_answers[:3]  # Take first 3
            
            choices.extend(wrong_answers)
        
        # If we don't have 4 choices yet, add some random ones
        while len(choices) < 4:
            random_wrong = correct_answer + random.randint(-10, 20)
            if random_wrong != correct_answer and random_wrong not in choices:
                choices.append(random_wrong)
        
        # Shuffle them up
        random.shuffle(choices)
        return choices


class ScoreManager:
    """Handles saving and loading high scores"""
    
    def __init__(self, filename='highscores.json'):
        self.filename = filename
        self._make_file_if_needed()
    
    def _make_file_if_needed(self):
        """Creates the file if it doesn't exist"""
        if not os.path.exists(self.filename):
            with open(self.filename, 'w') as f:
                json.dump([], f)
    
    def save_result(self, name, points, difficulty):
        """Saves a new score to the file"""
        # Clean up the name first
        clean_name = self._clean_name(name)
        
        # Make the new record
        new_record = {
            'player': clean_name,
            'score': points,
            'difficulty': difficulty,
            'date': time.strftime('%Y-%m-%d %H:%M:%S')
        }
        
        # Read existing scores
        try:
            with open(self.filename, 'r') as f:
                records = json.load(f)
        except:
            records = []
        
        # Add the new one
        records.append(new_record)
        
        # Sort by score (highest first)
        records.sort(key=lambda x: x['score'], reverse=True)
        
        # Keep only top 50 scores
        records = records[:50]
        
        # Save back to file
        try:
            with open(self.filename, 'w') as f:
                json.dump(records, f, indent=2)
        except Exception as e:
            print(f"Couldn't save score: {e}")
    
    def _clean_name(self, name):
        """Makes sure the name is safe to save"""
        # Remove any weird characters, keep only letters, numbers, spaces
        clean = ''.join(c for c in name if c.isalnum() or c.isspace())
        return clean.strip()[:20]  # Limit to 20 characters
    
    def get_records(self):
        """Gets all the saved scores"""
        try:
            with open(self.filename, 'r') as f:
                return json.load(f)
        except:
            return []


class AudioManager:
    """Handles all the sounds in the game"""
    
    def __init__(self):
        self.sounds_work = False
        if not pygame_works:
            print("Sound is turned off - pygame not available")
            return
        
        try:
            pygame.mixer.init()
            self.sounds_work = True
            self._load_sounds()
        except Exception as e:
            print(f"Couldn't start sound: {e}")
            self.sounds_work = False
    
    def _load_sounds(self):
        """Loads all the sound files"""
        if not pygame_works:
            return
        
        try:
            # Try to load background music
            pygame.mixer.music.load('assets/Sounds/bgm.wav')
            self.music_on = True
        except:
            self.music_on = False
        
        try:
            # Load sound effects
            self.correct_sound = pygame.mixer.Sound('assets/Sounds/correct.wav')
            self.wrong_sound = pygame.mixer.Sound('assets/Sounds/wrong.wav')
        except:
            self.correct_sound = None
            self.wrong_sound = None
    
    def toggle_music(self):
        """Turns music on or off"""
        if not pygame_works or not self.sounds_work:
            return False
        
        try:
            if self.music_on:
                pygame.mixer.music.pause()
                self.music_on = False
            else:
                pygame.mixer.music.unpause()
                self.music_on = True
            return True
        except:
            return False
    
    def play_correct(self):
        """Plays the happy sound when you get it right"""
        if pygame_works and self.sounds_work:
            try:
                self.correct_sound.play()
            except:
                pass
    
    def play_wrong(self):
        """Plays the sad sound when you get it wrong"""
        if pygame_works and self.sounds_work:
            try:
                self.wrong_sound.play()
            except:
                pass
    
    def stop_bg_music(self):
        """Stops the background music"""
        if pygame_works and self.sounds_work:
            try:
                pygame.mixer.music.stop()
            except:
                pass
    
    def cleanup(self):
        """Cleans up when the game ends"""
        if pygame_works and self.sounds_work:
            try:
                pygame.mixer.quit()
            except:
                pass
