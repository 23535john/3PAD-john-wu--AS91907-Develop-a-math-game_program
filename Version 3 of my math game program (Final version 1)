Based on my version 2  start to improve my code further: Here are the change evidence has been made . 
First File: Main.py (formerly Main File)
Key Improvements:
Replaced tuple-based page registration with dictionary for scalability
Added intelligent window sizing based on page type
Implemented automatic window centering for menu pages
Added proper resource cleanup on window close

class MathAdventureGame(tk.Tk):
    def __init__(self):
        # ... [initialization code] ...
        
    def _setup_container(self):
        self.container = tk.Frame(self)
        self.container.pack(fill='both', expand=True)
        self.container.grid_rowconfigure(0, weight=1)
        self.container.grid_columnconfigure(0, weight=1)

    def _register_pages(self):
        game_pages = {
            'StartPage': StartPage,
            'PlayerInfoMapPage': PlayerInfoMapPage,
            'GamePage': GamePage,
            'LeaderboardPage': LeaderboardPage
        }
        self.page_frames = {}
        for page_name, page_class in game_pages.items():
            frame = page_class(parent=self.container, controller=self)
            self.page_frames[page_name] = frame
            frame.grid(row=0, column=0, sticky='nsew')
    
    def _adjust_window_size(self, page_name):
        large_pages = ['PlayerInfoMapPage', 'GamePage']
        if page_name in large_pages:
            self.geometry('1100x800')
            self.resizable(True, True)
        else:
            self.geometry('780x620')
            self.resizable(False, False)
            self.update_idletasks()
            x = (self.winfo_screenwidth() // 2) - (780 // 2)
            y = (self.winfo_screenheight() // 2) - (620 // 2)
            self.geometry(f'780x620+{x}+{y}')

Improve my Player Information Page Enhancement
Key Improvements:

Added player name uniqueness check against leaderboard  / Implemented smart name suggestions for duplicates / Added floating SpongeBob-themed decorations
  
*Removed character selection to simplify UI
Enhanced visual design with themed colors and elements

File: Game_core.py
class PlayerInfoMapPage(tk.Frame):
    def confirm_name(self):
        # ... [validation code] ...
        
        # Check for duplicate names in leaderboard
        existing_records = score_manager.get_records()
        existing_names = [record.get('player', '').lower() for record in existing_records]
        
        if name.lower() in existing_names:
            suggestions = [f"{name}1", f"{name}2", f"{name}2024"]
            self.name_validation_label.config(
                text=f'âŒ "{name}" already exists!\nğŸ’¡ Try: {", ".join(suggestions)}', 
                fg='red'
            )
            return
        
    def _add_floating_decorations(self):
        decorations = ['â­', 'ğŸš', 'ğŸŒŠ', 'ğŸ™', 'ğŸ¦€', 'ğŸ¨']
        positions = [(0.1, 0.1), (0.9, 0.1), ...]
        for i, (relx, rely) in enumerate(positions):
            deco_label = tk.Label( ... )
            deco_label.place(relx=relx, rely=rely, anchor='center')

Jellyfish Management System
File: game_objects.py (new file)
Key Improvements:

Created dedicated class for jellyfish management
*Implemented collision detection algorithm  
Added press/release visual feedback
Used actual jellyfish images instead of circles
Improved natural movement with wave patterns

class JellyfishManager:
    def __init__(self, canvas, difficulty):
        self.jellyfish_images = self._load_jellyfish_images()
        
    def animate(self):
        # Collision detection
        min_distance = 100
        for other_jelly in self.jellyfish:
            if other_jelly != jelly:
                dx = new_x - other_jelly['x']
                dy = new_y - other_jelly['y']
                distance = math.sqrt(dx*dx + dy*dy)
                if distance < min_distance:
                    push_x = (dx / distance) * (min_distance - distance) * 0.5
                    push_y = (dy / distance) * (min_distance - distance) * 0.5
                    new_x += push_x
                    new_y += push_y
    
    def press_jellyfish(self, jelly_index):
        # Visual feedback
        self.canvas.itemconfig(jelly['bubble'], fill='#FFD700', outline='#FFA500', width=4)
        self.canvas.scale(jelly['jelly_id'], jelly['x'], jelly['y']-20, 1.1, 1.1)
        
    def release_jellyfish(self, jelly_index):
        # Revert visual changes
        self.canvas.itemconfig(jelly['bubble'], fill='#F4E4BC', outline='#DAA520', width=2)
        self.canvas.scale(jelly['jelly_id'], jelly['x'], jelly['y']-25, 1.0, 1.0)

Game Page UI and Flow Enhancements
File: Game_core.py
Key Improvements:

Added themed containers and visual decorations
Implemented custom completion dialog with options
Added duplicate click prevention
Enhanced feedback messages with encouraging text
Improved answer validation logic

class GamePage(tk.Frame):
    def _create_widgets(self):
        # Added themed containers and decorations
        question_container = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        canvas_container = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        feedback_container = tk.Frame(main_frame, bg='#87CEEB', bd=3, relief='raised')
        
    def game_completed(self):
        # Custom dialog with options
        dialog = tk.Toplevel()
        # Play Again, Back to Menu, View Leaderboard buttons
        
    def check_answer(self, selected):
        # Prevent multiple clicks
        if hasattr(self, '_answer_checked') and self._answer_checked:
            return
        self._answer_checked = True

Problem Generation System Overhaul
File: utils.py  Key Improvements:

Added 3 difficulty levels with multiple problem types

Created SpongeBob-themed context for all problems
Implemented intelligent distractor generation
Added geometry problem type for higher difficulty
Improved problem variety and educational value

class ProblemGenerator:
    def _make_easy_one(self):
        what_kind = random.choice(['math', 'counting', 'money'])
        if what_kind == 'math': return self._basic_math()
        elif what_kind == 'counting': return self._counting_stuff()
        else: return self._money_stuff()
        
    def _basic_math(self):
        # SpongeBob-themed problems
        thing = random.choice(self.stuff)
        problem = f"SpongeBob has {num1} {thing}s. If he gets {num2} times more..."
        
    def _geometry_problem(self):
        what_kind = random.choice(['area', 'perimeter'])
        # ... geometry problems ...
Leaderboard and Score Management
File: game_objects.py
Key Improvements:

Added gold highlighting for current player
Implemented score timestamp recording
Enhanced UI with themed borders
Improved scrolling and layout
Fixed score sorting and saving
class LeaderboardPage(tk.Frame):
    def refresh(self):
        # Highlight current player
        if i == highlight_index:
            bg_color = '#FFD700'  # Gold highlight
        
    def _create_widgets(self):
        # Added themed border
        border_frame = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        
class ScoreManager:
    def save_result(self, name, points, difficulty):
        # Add timestamp
        new_record = {
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
        }
 Audio System Improvements
File: utils.py
Key Improvements:

Added graceful degradation when pygame unavailable

Improved error messages

Better resource cleanup

Fixed music toggle feedback
class AudioManager:
    def __init__(self):
        if not pygame_works:
            print("Sound is turned off - pygame not available")
            return
        try:
            pygame.mixer.init()
            # ... load sounds ...
        except Exception as e:
            print(f"Couldn't start sound: {e}")
            self.sounds_work = False

Final changes of the  version :All the files stored:
Main file:import tkinter as tk
from Game_core import StartPage, PlayerInfoMapPage, GamePage
from game_objects import LeaderboardPage  # ä»æ–°æ–‡ä»¶å¯¼å…¥æ’è¡Œæ¦œ
from utils import AudioManager as SoundManager

class MathAdventureGame(tk.Tk):
    def __init__(self):
        super().__init__()
        
        # é…ç½®ä¸»çª—å£
        self.title('æµ·ç»µå®å®æ•°å­¦å†’é™©')
        self.geometry('780x620')
        
        # å°è¯•è®¾ç½®çª—å£å›¾æ ‡
        try:
            self.iconbitmap('assets/Images/spongebob.ico')
        except Exception:
            pass
        
        # åˆå§‹åŒ–æ¸¸æˆçŠ¶æ€å˜é‡
        self.player_name = ''  # ç©å®¶åç§°
        self.selected_difficulty = 'Easy'  # é»˜è®¤éš¾åº¦
        self.page_history = []  # é¡µé¢å†å²è®°å½•
        self.last_score = None  # ä¸Šä¸€æ¬¡æ¸¸æˆåˆ†æ•°
        
        # è®¾ç½®éŸ³é¢‘ç®¡ç†å™¨
        self.sound_manager = SoundManager()
        
        # åˆ›å»ºé¡µé¢å®¹å™¨
        self._setup_container()
        
        # æ³¨å†Œæ‰€æœ‰é¡µé¢
        self._register_pages()
        
        # è®¾ç½®åˆå§‹é¡µé¢
        self.current_page = 'StartPage'
        self._show_frame('StartPage')

    def _setup_container(self):
        self.container = tk.Frame(self)
        self.container.pack(fill='both', expand=True)
        self.container.grid_rowconfigure(0, weight=1)
        self.container.grid_columnconfigure(0, weight=1)

    def _register_pages(self):
        # é¡µé¢åˆ—è¡¨
        game_pages = {
            'StartPage': StartPage,
            'PlayerInfoMapPage': PlayerInfoMapPage,
            'GamePage': GamePage,
            'LeaderboardPage': LeaderboardPage  # ä½¿ç”¨æ–°ä½ç½®çš„æ’è¡Œæ¦œ
        }
        
        # é¡µé¢æ¡†æ¶å­—å…¸
        self.page_frames = {}
        
        # åˆ›å»ºå¹¶æ³¨å†Œæ¯ä¸ªé¡µé¢
        for page_name, page_class in game_pages.items():
            frame = page_class(parent=self.container, controller=self)
            self.page_frames[page_name] = frame
            frame.grid(row=0, column=0, sticky='nsew')

    def _show_frame(self, page_name):
        # æ›´æ–°é¡µé¢å†å²è®°å½•
        if self.current_page and self.current_page != page_name and self.current_page != 'StartPage':
            self.page_history.append(self.current_page)
        
        # è·å–ç›®æ ‡é¡µé¢
        target_frame = self.page_frames[page_name]
        
        # æ ¹æ®é¡µé¢è°ƒæ•´çª—å£å¤§å°
        self._adjust_window_size(page_name)
        
        # é¡µé¢æ˜¾ç¤ºå‰å¤„ç†
        self._pre_display_processing(page_name, target_frame)
        
        # æ‰§è¡Œé¡µé¢åˆ‡æ¢
        self.current_page = page_name
        target_frame.tkraise()
        
        # å¦‚æœæ˜¯èœå•é¡µé¢ï¼Œç¡®ä¿çª—å£çŠ¶æ€æ­£ç¡®
        if page_name == 'StartPage':
            self.update_idletasks()
            # å¼ºåˆ¶æ›´æ–°çª—å£çŠ¶æ€
            self.after(100, self._ensure_menu_size)
    
    def _ensure_menu_size(self):
        """ç¡®ä¿èœå•é¡µé¢ä¿æŒæ­£ç¡®å¤§å°"""
        if self.current_page == 'StartPage':
            current_geometry = self.geometry()
            if '780x620' not in current_geometry:
                self._reset_to_menu_size()

    def _adjust_window_size(self, page_name):
        # éœ€è¦è¾ƒå¤§å°ºå¯¸çš„é¡µé¢
        large_pages = ['PlayerInfoMapPage', 'GamePage']
        
        if page_name in large_pages:
            # ç¡®ä¿çª—å£ä¸æ˜¯æœ€å¤§åŒ–çŠ¶æ€
            try:
                self.state('normal')
            except:
                pass
            self.geometry('1100x800')
            self.resizable(True, True)  # å…è®¸è°ƒæ•´å¤§å°
        else:
            # èœå•é¡µé¢ - å¼ºåˆ¶é‡ç½®åˆ°åŸå§‹å¤§å°å¹¶å±…ä¸­
            # ç¡®ä¿çª—å£ä¸æ˜¯æœ€å¤§åŒ–çŠ¶æ€
            try:
                self.state('normal')
            except:
                pass
            self.geometry('780x620')
            self.resizable(False, False)  # èœå•é¡µé¢ä¸å…è®¸è°ƒæ•´å¤§å°
            
            # ç¡®ä¿çª—å£å±…ä¸­æ˜¾ç¤º
            self.update_idletasks()  # æ›´æ–°çª—å£ä¿¡æ¯
            x = (self.winfo_screenwidth() // 2) - (780 // 2)
            y = (self.winfo_screenheight() // 2) - (620 // 2)
            self.geometry(f'780x620+{x}+{y}')

    def _pre_display_processing(self, page_name, frame):
        # æ¸¸æˆé¡µé¢éœ€è¦é‡ç½®æ¸¸æˆ
        if page_name == 'GamePage':
            if not frame.reset_game():
                return
        
        # æ’è¡Œæ¦œé¡µé¢éœ€è¦åˆ·æ–°æ•°æ®
        if page_name == 'LeaderboardPage':
            frame.refresh()

    def show_frame(self, page_name):
        self._show_frame(page_name)

    def go_to_previous_page(self):
        if self.page_history:
            previous_page = self.page_history.pop()
            self._show_frame(previous_page)
        else:
            # ç¡®ä¿è¿”å›èœå•æ—¶é‡ç½®çª—å£å¤§å°
            self._show_frame('StartPage')
    
    def _reset_to_menu_size(self):
        """å¼ºåˆ¶é‡ç½®çª—å£åˆ°èœå•å¤§å°"""
        # å¦‚æœçª—å£è¢«æœ€å¤§åŒ–ï¼Œå…ˆæ¢å¤æ­£å¸¸çŠ¶æ€
        try:
            self.state('normal')
        except:
            pass
        
        self.geometry('780x620')
        self.resizable(False, False)
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (780 // 2)
        y = (self.winfo_screenheight() // 2) - (620 // 2)
        self.geometry(f'780x620+{x}+{y}')

    def on_window_close(self):
        self.sound_manager.stop_bg_music()
        self.destroy()

    def destroy(self):
        # æ¸…ç†éŸ³é¢‘èµ„æº
        self.sound_manager.cleanup()
        # è°ƒç”¨çˆ¶ç±»é”€æ¯æ–¹æ³•
        super().destroy()

# ç¨‹åºå…¥å£
if __name__ == '__main__':
    # åˆ›å»ºæ¸¸æˆåº”ç”¨å®ä¾‹
    game_app = MathAdventureGame()
    
    # ç»‘å®šçª—å£å…³é—­äº‹ä»¶
    game_app.protocol("WM_DELETE_WINDOW", game_app.on_window_close)
    
    # å¯åŠ¨ä¸»äº‹ä»¶å¾ªç¯
    game_app.mainloop()


Game_core file:

import tkinter as tk
from tkinter import messagebox
from utils import ProblemGenerator as ProblemBank, ScoreManager
from game_objects import JellyfishManager  # ä»æ–°æ–‡ä»¶å¯¼å…¥

# æ¸¸æˆé…ç½®
QUESTIONS_PER_GAME = 12
TIME_PER_QUESTION = 60
LEVEL_NAMES = {
    'Easy': "Jellyfish Fields",
    'Medium': "Krusty Krab",
    'Hard': "Squidward's House"
}
LEVEL_POINTS = {'Easy': 50, 'Medium': 100, 'Hard': 300}
BACKGROUND_COLORS = {
    'Easy': '#88cfff',   # æµ…è“ - æ°´æ¯ç”°
    'Medium': '#ff9966', # æµ…æ©™ - èŸ¹å ¡ç‹
    'Hard': '#9b59b6'    # æµ…ç´« - ç« é±¼å“¥çš„å®¶
}

STATUS_BAR_COLOR = '#3A6EA5'  # æ·±è“çŠ¶æ€æ 
TEXT_COLOR = '#2C3E50'        # æ·±è“æ–‡æœ¬

class StartPage(tk.Frame):
    def __init__(self, parent, controller):
        super().__init__(parent, bg='#76deee')
        self.controller = controller
        self._create_widgets()
    
    def _create_widgets(self):
        """åˆ›å»ºUIå…ƒç´ """
        # èƒŒæ™¯å›¾ç‰‡
        try:
            bg_image = tk.PhotoImage(file='assets/Images/bg_menu.png')
            bg_label = tk.Label(self, image=bg_image)
            bg_label.image = bg_image
            bg_label.place(x=0, y=0, relwidth=1, relheight=1)
        except Exception:
            # å›¾ç‰‡åŠ è½½å¤±è´¥æ—¶çš„å›é€€æ–¹æ¡ˆ
            self.config(bg='#82d4ed')
        
        # æ ‡é¢˜
        title_frame = tk.Frame(self, bg='#76deee')
        title_frame.place(relx=0.5, rely=0.2, anchor='center')
        
        # æŒ‰é’®æ ·å¼
        btn_style = {
            'font': ('Comic Sans MS', 18),
            'bg': '#FFD700', 
            'fg': 'black',
            'activebackground': '#FFA500',
            'relief': 'raised', 
            'bd': 3,
            'width': 13,
            'pady': 7
        }
        
        # æŒ‰é’®å®¹å™¨
        btn_frame = tk.Frame(self, bg="#76deee")
        btn_frame.place(relx=0.5, rely=0.5, anchor='center')
        
        # æŒ‰é’®
        tk.Button(
            btn_frame, 
            text='Start Game', 
            **btn_style,
            command=lambda: self.controller.show_frame('PlayerInfoMapPage')
        ).pack(pady=10)
        
        tk.Button(
            btn_frame, 
            text='Leaderboard', 
            **btn_style,
            command=lambda: self.controller.show_frame('LeaderboardPage')
        ).pack(pady=10)
        
        tk.Button(
            btn_frame, 
            text='Exit Game', 
            **btn_style,
            command=self.controller.destroy
        ).pack(pady=10)
        
        # éŸ³ä¹åˆ‡æ¢æŒ‰é’®
        self.music_btn = tk.Button(
            self, 
            text='ğŸµ', 
            font=('Arial', 14), 
            bg="#AAFF00", 
            bd=0,
            command=self.toggle_music
        )
        self.music_btn.place(x=740, y=10)
        
    def toggle_music(self):
        """åˆ‡æ¢éŸ³ä¹å¹¶æ›´æ–°æŒ‰é’®"""
        music_on = self.controller.sound_manager.toggle_music()
        self.music_btn.config(text='ğŸµON' if music_on else 'ğŸ”‡OFF')

class PlayerInfoMapPage(tk.Frame):
    """åˆå¹¶çš„ç”¨æˆ·ä¿¡æ¯è¾“å…¥å’Œåœ°å›¾é€‰æ‹©é¡µé¢"""
    def __init__(self, parent, controller):
        super().__init__(parent, bg='#FFE4B5')  # æ›´æ”¹ä¸ºæµ·ç»µå®å®ä¸»é¢˜çš„æ©™è‰²
        self.controller = controller
        self._create_widgets()
        self.name_confirmed = False
    
    def _create_widgets(self):
        """åˆ›å»ºUIå…ƒç´ """
        # èƒŒæ™¯ - æµ·ç»µå®å®ä¸»é¢˜
        try:
            bg_image = tk.PhotoImage(file='assets/Images/krusty_krab.png')
            bg_label = tk.Label(self, image=bg_image)
            bg_label.image = bg_image
            bg_label.place(x=0, y=0, relwidth=1, relheight=1)
        except Exception:
            self.config(bg='#FFE4B5')  # æµ·ç»µå®å®ä¸»é¢˜æ©™è‰²èƒŒæ™¯
        
        # æ ‡é¢˜ - æµ·ç»µå®å®ä¸»é¢˜å¢å¼ºç‰ˆæœ¬
        title_frame = tk.Frame(self, bg='#FFE4B5')
        title_frame.place(relx=0.5, rely=0.05, anchor='center')
        
        # æ·»åŠ æ¬¢è¿è£…é¥°
        welcome_frame = tk.Frame(title_frame, bg='#FFE4B5')
        welcome_frame.pack(pady=5)
        
        tk.Label(
            welcome_frame, 
            text='ğŸŒŸ Welcome to Bikini Bottom! ğŸŒŸ',
            font=('Comic Sans MS', 18, 'bold'),
            bg='#FFE4B5', 
            fg='#FFD700'
        ).pack()
        
        tk.Label(
            welcome_frame, 
            text='ğŸ™ Ready for a math adventure? ğŸ™',
            font=('Comic Sans MS', 14),
            bg='#FFE4B5', 
            fg='#006994'
        ).pack(pady=5)
        
        # ç”¨æˆ·ä¿¡æ¯è¡¨å•æ¡†æ¶ - æµ·ç»µå®å®ä¸»é¢˜
        form_frame = tk.Frame(self, bg='#FFD700', bd=5, relief='groove')  # æµ·ç»µå®å®é»„è‰²
        form_frame.place(relx=0.5, rely=0.2, anchor='center', width=400, height=250)
        
        # ç”¨æˆ·åè¾“å…¥ - æµ·ç»µå®å®ä¸»é¢˜ç‰ˆæœ¬
        tk.Label(
            form_frame, 
            text="Enter Your Username: ğŸ§½", 
            bg='#FFD700',
            font=('Comic Sans MS', 14, 'bold'),
            fg='#2C3E50'
        ).pack(pady=5)
        
        # æ·»åŠ æç¤ºæ–‡æœ¬
        tk.Label(
            form_frame,
            text='(Pick a fun username, 3-15 characters)',
            bg='#FFD700',
            font=('Comic Sans MS', 10),
            fg='#666666'
        ).pack(pady=2)
        
        self.name_var = tk.StringVar()
        name_entry = tk.Entry(
            form_frame, 
            textvariable=self.name_var, 
            font=('Comic Sans MS', 12), 
            width=25,
            relief='sunken',
            bd=2
        )
        name_entry.pack(pady=5)
        name_entry.focus_set()
        
        # æ·»åŠ éªŒè¯æç¤ºæ ‡ç­¾
        self.name_validation_label = tk.Label(
            form_frame,
            text='',
            bg='#FFD700',
            font=('Comic Sans MS', 10),
            fg='red'
        )
        self.name_validation_label.pack(pady=2)
        
        # æ·»åŠ ç¡®è®¤æŒ‰é’®
        confirm_btn = tk.Button(
            form_frame, 
            text='Confirm Name', 
            font=('Comic Sans MS', 12),
            bg='#4CAF50', 
            fg='white',
            padx=10,
            pady=5,
            command=self.confirm_name
        )
        confirm_btn.pack(pady=10)
        
        # ç§»é™¤è§’è‰²é€‰æ‹©åŒºåŸŸ - ç®€åŒ–ç•Œé¢
        
        # åœ°å›¾æ ‡é¢˜ - æµ·ç»µå®å®ä¸»é¢˜å¢å¼ºç‰ˆæœ¬
        map_title_frame = tk.Frame(self, bg='#FFE4B5')
        map_title_frame.place(relx=0.5, rely=0.4, anchor='center')
        
        # æ·»åŠ è£…é¥°æ€§å…ƒç´ 
        decoration_frame = tk.Frame(map_title_frame, bg='#FFE4B5')
        decoration_frame.pack(pady=5)
        
        tk.Label(
            decoration_frame, 
            text='â­ ğŸš â­',
            font=('Comic Sans MS', 16),
            bg='#FFE4B5', 
            fg='#FFD700'
        ).pack()
        
        tk.Label(
            map_title_frame, 
            text='ğŸ—ºï¸ Choose Your Adventure:',
            font=('Comic Sans MS', 22, 'bold'),
            bg='#FFE4B5', 
            fg='#006994'
        ).pack(pady=5)
        
        tk.Label(
            map_title_frame, 
            text='ğŸ® Click on a location to start your math journey!',
            font=('Comic Sans MS', 12),
            bg='#FFE4B5', 
            fg='#666666'
        ).pack(pady=5)
        
        # æ·»åŠ æ›´å¤šè£…é¥°
        tk.Label(
            decoration_frame, 
            text='â­ ğŸš â­',
            font=('Comic Sans MS', 16),
            bg='#FFE4B5', 
            fg='#FFD700'
        ).pack()
        
        # åœ°å›¾é€‰æ‹©æ¡†æ¶
        map_frame = tk.Frame(self, bg='#FFE4B5')
        map_frame.place(relx=0.5, rely=0.65, anchor='center')
        
        # å…³å¡æè¿°å’Œé¢œè‰² - æµ·ç»µå®å®ä¸»é¢˜ç¾åŒ–ç‰ˆæœ¬
        level_info = [
            ("ğŸŒŠ Jellyfish Fields\n\nğŸ¯ Easy Difficulty\nğŸ’ 50 points per question\n\nğŸ™ Perfect for beginners!", '#87CEEB', 'Easy', 'ğŸ™'),
            ("ğŸ” Krusty Krab\n\nâš¡ Medium Difficulty\nğŸ’ 100 points per question\n\nğŸ¦€ For experienced players!", '#FFB347', 'Medium', 'ğŸ¦€'),
            ("ğŸ¨ Squidward's House\n\nğŸ”¥ Hard Difficulty\nğŸ’ 300 points per question\n\nğŸ· Ultimate challenge!", '#DDA0DD', 'Hard', 'ğŸ·')
        ]
        
        for i, (desc, color, level, emoji) in enumerate(level_info):
            # åˆ›å»ºæŒ‰é’®å®¹å™¨æ¡†æ¶ - æ›´å¤§å°ºå¯¸
            btn_container = tk.Frame(map_frame, bg=color, bd=5, relief='raised')
            btn_container.grid(row=0, column=i, padx=20, pady=15)
            
            # æ·»åŠ è£…é¥°æ€§è¾¹æ¡†
            border_frame = tk.Frame(btn_container, bg='#FFD700', bd=3, relief='sunken')
            border_frame.pack(fill='both', expand=True, padx=4, pady=4)
            
            level_btn = tk.Button(
                border_frame, 
                text=f"{emoji}\n{desc}",
                font=('Comic Sans MS', 14, 'bold'),
                bg=color, 
                fg='white', 
                width=22, 
                height=8,
                relief='flat',
                bd=0,
                activebackground='#FFD700',
                activeforeground='#2C3E50',
                cursor='hand2',
                command=lambda l=level: self.start_level(l)
            )
            level_btn.pack(fill='both', expand=True, padx=3, pady=3)
        
        # ä¸»èœå•æŒ‰é’® - ç¾åŒ–ç‰ˆæœ¬
        menu_btn = tk.Button(
            self, 
            text='ğŸ  Main Menu', 
            font=('Comic Sans MS', 14, 'bold'),
            bg='#FFD700', 
            fg='#2C3E50',
            padx=15,
            pady=8,
            relief='raised',
            bd=3,
            command=lambda: self.controller.show_frame('StartPage')
        )
        menu_btn.place(relx=0.5, rely=0.92, anchor='center')
        
        # æ·»åŠ çŠ¶æ€æ ‡ç­¾ - ç§»åˆ°æ›´åˆé€‚çš„ä½ç½®
        self.status_label = tk.Label(
            self, 
            text='Please enter and confirm your name first',
            font=('Comic Sans MS', 12),
            bg='#FFE4B5',
            fg='#2C3E50'
        )
        self.status_label.place(relx=0.5, rely=0.32, anchor='center')
        
        # æ·»åŠ æµ®åŠ¨è£…é¥°å…ƒç´ 
        self._add_floating_decorations()

    def confirm_name(self):
        """ç¡®è®¤ç©å®¶åç§°"""
        name = self.name_var.get().strip()
        
        # æ¸…é™¤ä¹‹å‰çš„éªŒè¯æ¶ˆæ¯
        self.name_validation_label.config(text='')
        
        # éªŒè¯åç§°
        if not name:
            self.name_validation_label.config(text='âŒ Name cannot be empty!', fg='red')
            return
            
        if len(name) < 3:
            self.name_validation_label.config(text='âŒ Name must be at least 3 characters long!', fg='red')
            return
            
        if len(name) > 15:
            self.name_validation_label.config(text='âŒ Name too long (max 15 characters)!', fg='red')
            return
            
        if not name.replace(" ", "").isalnum():
            self.name_validation_label.config(text='âŒ Name can only contain letters and numbers!', fg='red')
            return
        
        # æ£€æŸ¥é‡å¤åç§°
        from utils import ScoreManager
        score_manager = ScoreManager()
        existing_records = score_manager.get_records()
        existing_names = [record.get('player', '').lower() for record in existing_records]
        
        if name.lower() in existing_names:
            # æä¾›æ›´å…·ä½“çš„å»ºè®®
            suggestions = [
                f"{name}1", f"{name}2", f"{name}2024", f"{name}_player", 
                f"Super{name}", f"{name}Math", f"{name}Star"
            ]
            suggestion_text = ", ".join(suggestions[:3])  # åªæ˜¾ç¤ºå‰3ä¸ªå»ºè®®
            
            self.name_validation_label.config(
                text=f'âŒ "{name}" already exists in the leaderboard!\nğŸ’¡ Try: {suggestion_text}', 
                fg='red'
            )
            return
        
        # åç§°æœ‰æ•ˆ
        self.name_confirmed = True
        self.name_validation_label.config(text='âœ… Name confirmed! Choose your difficulty level.', fg='green')
        self.status_label.config(text=f'Welcome, {name}! Ready to play!', fg='green')

    def start_level(self, level):
        """å¼€å§‹é€‰æ‹©çš„æ¸¸æˆå…³å¡"""
        if not self.name_confirmed:
            self.status_label.config(text='Please confirm your name first!', fg='red')
            return
            
        name = self.name_var.get().strip()
        self.controller.player_name = name
        self.controller.selected_difficulty = level
        self.controller.show_frame('GamePage')

    # ç§»é™¤è§’è‰²é€‰æ‹©ç›¸å…³æ–¹æ³•
    
    def _add_floating_decorations(self):
        """æ·»åŠ æµ®åŠ¨è£…é¥°å…ƒç´ """
        decorations = ['â­', 'ğŸš', 'ğŸŒŠ', 'ğŸ™', 'ğŸ¦€', 'ğŸ¨']
        positions = [
            (0.1, 0.1), (0.9, 0.1), (0.1, 0.9), (0.9, 0.9),
            (0.2, 0.2), (0.8, 0.2), (0.2, 0.8), (0.8, 0.8)
        ]
        
        for i, (relx, rely) in enumerate(positions):
            if i < len(decorations):
                deco_label = tk.Label(
                    self,
                    text=decorations[i],
                    font=('Comic Sans MS', 20),
                    bg='#FFE4B5',
                    fg='#FFD700'
                )
                deco_label.place(relx=relx, rely=rely, anchor='center')
    
    def reset_player_info(self):
        """é‡ç½®ç©å®¶ä¿¡æ¯é¡µé¢"""
        # æ¸…ç©ºåç§°è¾“å…¥
        self.name_var.set('')
        self.name_confirmed = False
        
        # é‡ç½®éªŒè¯æ¶ˆæ¯
        self.name_validation_label.config(text='')
        self.status_label.config(text='Please enter and confirm your name first', fg='#2C3E50')

class GamePage(tk.Frame):
    def __init__(self, parent, controller):
        super().__init__(parent, bg='white')
        self.controller = controller
        self.jellyfish_manager = None  # æ°´æ¯ç®¡ç†å™¨
        
        # å®šæ—¶å™¨ç®¡ç†
        self._active_timers = []
        self._game_active = False
        
        self._create_widgets()
        self.reset_game()
    
    def _create_widgets(self):
        """åˆ›å»ºæ¸¸æˆç•Œé¢å…ƒç´  - æµ·ç»µå®å®ä¸»é¢˜å¢å¼ºç‰ˆ"""
        # ä¸»æ¡†æ¶ - æµ·ç»µå®å®ä¸»é¢˜èƒŒæ™¯
        self.config(bg='#FFE4B5')  # æµ·ç»µå®å®æ©™è‰²èƒŒæ™¯
        main_frame = tk.Frame(self, bg='#FFE4B5')
        main_frame.pack(fill='both', expand=True, padx=15, pady=15)
        
        # é¡¶éƒ¨å¯¼èˆªæ  - åŒ…å«è¿”å›æŒ‰é’®
        top_nav = tk.Frame(main_frame, bg='#FFD700', height=60, bd=3, relief='raised')
        top_nav.pack(fill='x', pady=(0, 10))
        top_nav.pack_propagate(False)
        
        # è¿”å›åœ°å›¾æŒ‰é’® - ç§»åˆ°é¡¶éƒ¨å³ä¾§ï¼Œæ›´æ˜¾çœ¼
        back_btn = tk.Button(
            top_nav, 
            text='ğŸ—ºï¸ Back to Map', 
            font=('Comic Sans MS', 12, 'bold'),
            bg='#FF6B35',  # æµ·ç»µå®å®æ©™è‰²
            fg='white',
            padx=15,
            pady=8,
            relief='raised',
            bd=3,
            cursor='hand2',
            command=self.return_to_map
        )
        back_btn.pack(side='right', padx=15, pady=10)
        
        # æ¸¸æˆæ ‡é¢˜
        game_title = tk.Label(
            top_nav,
            text='ğŸ§½ SpongeBob Math Adventure ğŸ§½',
            font=('Comic Sans MS', 16, 'bold'),
            bg='#FFD700',
            fg='#2C3E50'
        )
        game_title.pack(side='left', padx=15, pady=10)
    
        status_bar = tk.Frame(main_frame, bg=STATUS_BAR_COLOR, height=50)
        status_bar.pack(fill='x', pady=(0, 10))
        
        self.lives_frame = tk.Frame(status_bar, bg=STATUS_BAR_COLOR)
        self.lives_frame.pack(side='left', padx=15)
        
        try:
            self.heart_img = tk.PhotoImage(file='assets/Images/heart.png')
            self.heart_img = self.heart_img.subsample(4, 4)
        except Exception:
            self.heart_img = None
        
        self.lives_labels = []
        for i in range(3):
            if self.heart_img:
                label = tk.Label(self.lives_frame, image=self.heart_img, bg=STATUS_BAR_COLOR)
            else:
                label = tk.Label(self.lives_frame, text='â™¥', 
                            font=('Comic Sans MS', 20), 
                            fg='#FF6B6B', bg=STATUS_BAR_COLOR)
            label.pack(side='left', padx=2)
            self.lives_labels.append(label)
        
        # åˆ†æ•°æ˜¾ç¤º
        self.score_label = tk.Label(
            status_bar, 
            text='Score: 0', 
            font=('Comic Sans MS', 16), 
            fg='#FFF44F',
            bg=STATUS_BAR_COLOR
        )
        self.score_label.pack(side='left', padx=15)
        
        # è®¡æ—¶å™¨æ˜¾ç¤º
        self.timer_label = tk.Label(
            status_bar, 
            text='Time: 20s', 
            font=('Comic Sans MS', 16), 
            fg='white', 
            bg=STATUS_BAR_COLOR
        )
        self.timer_label.pack(side='right', padx=15)
        
        # é—®é¢˜è®¡æ•°å™¨
        self.counter_label = tk.Label(
            status_bar, 
            text='Question: 1/12', 
            font=('Comic Sans MS', 16), 
            fg='white', 
            bg=STATUS_BAR_COLOR
        )
        self.counter_label.pack(side='right', padx=15)
    
        # é—®é¢˜æ˜¾ç¤º - æµ·ç»µå®å®ä¸»é¢˜ç‰ˆæœ¬
        question_container = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        question_container.pack(fill='x', padx=15, pady=10)
        
        # é—®é¢˜æ ‡é¢˜è£…é¥°
        question_title = tk.Label(
            question_container,
            text='ğŸ§½ Question Time! ğŸ§½',
            font=('Comic Sans MS', 12, 'bold'),
            bg='#FFD700',
            fg='#2C3E50'
        )
        question_title.pack(pady=(5, 0))
        
        self.question_label = tk.Label(
            question_container, 
            text='', 
            font=('Comic Sans MS', 16, 'bold'), 
            bg='#FFD700', 
            fg='#2C3E50',
            wraplength=600,
            pady=15
        )
        self.question_label.pack(fill='x', padx=15, pady=10)
    
        # æ°´æ¯ç”»å¸ƒå®¹å™¨ - æµ·ç»µå®å®ä¸»é¢˜å¢å¼ºç‰ˆ
        canvas_container = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        canvas_container.pack(fill='both', expand=True, pady=10)
        
        # æ·»åŠ ç”»å¸ƒæ ‡é¢˜è£…é¥°
        canvas_title = tk.Frame(canvas_container, bg='#FFD700')
        canvas_title.pack(side='top', pady=(5, 0))
        
        title_label = tk.Label(
            canvas_title,
            text='ğŸ  Catch the Jellyfish! ğŸ ',
            font=('Comic Sans MS', 16, 'bold'),
            bg='#FFD700',
            fg='#006994'
        )
        title_label.pack(side='left', padx=15)
        
        # æ·»åŠ æµ·ç»µå®å®è£…é¥°
        decoration_label = tk.Label(
            canvas_title,
            text='ğŸ§½ ğŸ¦€ ğŸ™ ğŸ  â­',
            font=('Comic Sans MS', 14),
            bg='#FFD700',
            fg='#FF6B35'
        )
        decoration_label.pack(side='right', padx=15)
        
        # ç”»å¸ƒè¾¹æ¡†
        canvas_border = tk.Frame(canvas_container, bg='#FF6B35', bd=2, relief='sunken')
        canvas_border.pack(fill='both', expand=True, padx=5, pady=5)
    
        self.canvas = tk.Canvas(canvas_border, bg='#87CEEB', highlightthickness=0)
        self.canvas.pack(fill='both', expand=True, padx=2, pady=2)
        
        # æ·»åŠ æµ·æ´‹è£…é¥°å…ƒç´ 
        self._add_ocean_decorations()
    
        # åé¦ˆæ ‡ç­¾ - æµ·ç»µå®å®ä¸»é¢˜ç‰ˆæœ¬
        feedback_container = tk.Frame(main_frame, bg='#87CEEB', bd=3, relief='raised')
        feedback_container.pack(fill='x', pady=10)
        
        # åé¦ˆæ ‡é¢˜è£…é¥°
        feedback_title = tk.Label(
            feedback_container,
            text='ğŸ’¬ Feedback Zone ğŸ’¬',
            font=('Comic Sans MS', 10, 'bold'),
            bg='#87CEEB',
            fg='#2C3E50'
        )
        feedback_title.pack(pady=(3, 0))
        
        self.feedback_label = tk.Label(
            feedback_container, 
            text='', 
            font=('Comic Sans MS', 14, 'bold'), 
            bg='#87CEEB',
            fg='#2C3E50',
            height=1
        )
        self.feedback_label.pack(fill='x', padx=10, pady=5)
    
        # åº•éƒ¨è£…é¥°æ  - æµ·ç»µå®å®ä¸»é¢˜
        bottom_decor = tk.Frame(main_frame, bg='#FFD700', height=40, bd=2, relief='sunken')
        bottom_decor.pack(side='bottom', fill='x', pady=(10, 0))
        bottom_decor.pack_propagate(False)
        
        # æ·»åŠ æµ·ç»µå®å®ä¸»é¢˜è£…é¥°
        decor_label = tk.Label(
            bottom_decor,
            text='ğŸ™ ğŸ¦€ ğŸ§½ ğŸ  â­ ğŸš',
            font=('Comic Sans MS', 14),
            bg='#FFD700',
            fg='#FF6B35'
        )
        decor_label.pack(expand=True, pady=8)
    
    def _add_ocean_decorations(self):
        """æ·»åŠ æµ·æ´‹è£…é¥°å…ƒç´ """
        # æ·»åŠ æ°”æ³¡è£…é¥°
        for i in range(8):
            x = 30 + i * 80
            y = 20 + (i % 3) * 15
            self.canvas.create_oval(
                x, y, x+8, y+8,
                fill='', outline='#E0F6FF', width=1,
                tags='decoration'
            )
        
        # æ·»åŠ æµ·æ˜Ÿè£…é¥°
        for i in range(4):
            x = 60 + i * 120
            y = 40 + (i % 2) * 20
            self.canvas.create_text(
                x, y, text='â­',
                font=('Comic Sans MS', 10),
                fill='#FFD700',
                tags='decoration'
            )
        
        # æ·»åŠ çŠç‘šè£…é¥°
        for i in range(3):
            x = 50 + i * 150
            y = 350  # å›ºå®šåœ¨åº•éƒ¨
            self.canvas.create_text(
                x, y, text='ğŸŒ¿',
                font=('Comic Sans MS', 12),
                fill='#228B22',
                tags='decoration'
            )

    def cancel_all_timers(self):
        """å–æ¶ˆæ‰€æœ‰å®šæ—¶ä»»åŠ¡"""
        for timer_id in self._active_timers:
            try:
                self.after_cancel(timer_id)
            except:
                pass
        self._active_timers = []
        
        if self.jellyfish_manager:
            self.jellyfish_manager.stop_animations()

    def return_to_map(self):
        if messagebox.askyesno("Confirm", "Exit current level? Progress will be lost."):
            self.cancel_all_timers()
            self._game_active = False
            self.controller.show_frame('PlayerInfoMapPage')

    def reset_game(self):
        self.cancel_all_timers()
        self._game_active = True
        self.question_count = 0
        self.score = 0
        self.lives = 3
        
        # è®¾ç½®èƒŒæ™¯é¢œè‰²
        self.bg_color = BACKGROUND_COLORS.get(self.controller.selected_difficulty, 'white')
        self.config(bg=self.bg_color)
        self.question_label.config(bg=self.bg_color)
        self.feedback_label.config(bg=self.bg_color)
        
        # åˆå§‹åŒ–æ°´æ¯ç®¡ç†å™¨
        self.jellyfish_manager = JellyfishManager(self.canvas, self.controller.selected_difficulty)
        
        # åˆå§‹åŒ–é—®é¢˜ç”Ÿæˆå™¨
        self.pb = ProblemBank(self.controller.selected_difficulty)
        
        # æ›´æ–°ç”Ÿå‘½å€¼æ˜¾ç¤º
        for i, label in enumerate(self.lives_labels):
            label.config(state='normal' if i < self.lives else 'disabled')
    
        # å¼€å§‹æ¸¸æˆ
        self.next_question()
        return True

    def update_status(self):
        """æ›´æ–°çŠ¶æ€æ˜¾ç¤º"""
        self.score_label.config(text=f'Score: {self.score}')
        
        for i, label in enumerate(self.lives_labels):
            label.config(state='normal' if i < self.lives else 'disabled')
        
        self.counter_label.config(text=f'Question: {self.question_count}/{QUESTIONS_PER_GAME}')

    def next_question(self):
        """åŠ è½½ä¸‹ä¸€é¢˜"""
        if not self._game_active:
            return
            
        if self.question_count >= QUESTIONS_PER_GAME:
            self.game_completed()
            return
            
        self.question_count += 1
        
        # é‡ç½®ç­”æ¡ˆæ£€æŸ¥çŠ¶æ€ - é˜²æ­¢é‡å¤ç‚¹å‡»
        self._answer_checked = False
        
        # å–æ¶ˆä¹‹å‰çš„åŠ¨ç”»å’Œè®¡æ—¶å™¨
        self.cancel_all_timers()
        
        problem, answer, options = self.pb.create_problem()
        self.correct_answer = answer
        self.options = options
        
        # æ›´æ–°UI
        level_name = LEVEL_NAMES.get(self.controller.selected_difficulty, self.controller.selected_difficulty)
        self.question_label.config(text=f"{level_name}\n\n{problem}")
        self.feedback_label.config(text='')
        self.update_status()
        
        # åˆ›å»ºæ°´æ¯
        self.create_jellyfish(options)
        
        # å¼€å§‹è®¡æ—¶å™¨
        self.time_left = TIME_PER_QUESTION
        self.timer_label.config(text=f'Time: {self.time_left}s')
        self.start_timer()
    
    def start_timer(self):
        """å¯åŠ¨è®¡æ—¶å™¨"""
        if not self._game_active:
            return
            
        self.update_timer()

    def update_timer(self):
        """æ›´æ–°è®¡æ—¶å™¨"""
        if not self._game_active or not self.winfo_ismapped():
            return
        
        if self.time_left <= 0:
            self.handle_timeout()
            return
        
        self.time_left -= 1
        self.timer_label.config(text=f'Time: {self.time_left}s')
        
        if self._active_timers:
            self.after_cancel(self._active_timers[0])
        
        timer_id = self.after(1000, self.update_timer)
        self._active_timers = [timer_id]

    def handle_timeout(self):
        """å¤„ç†è¶…æ—¶"""
        if not self._game_active:
            return
            
        self.controller.sound_manager.play_wrong()
        self.lives -= 1
        self.feedback_label.config(text='Time up!', fg='red')
        self.update_status()
        
        # ç¦ç”¨æ‰€æœ‰æ°´æ¯ç‚¹å‡»
        self.disable_jellyfish()
        
        if self.lives <= 0:
            self.after(1500, self.game_over)
        else:
            self.after(1500, self.next_question)

    def create_jellyfish(self, options):
        """ä½¿ç”¨æ°´æ¯ç®¡ç†å™¨åˆ›å»ºæ°´æ¯"""
        self.jellyfish = self.jellyfish_manager.create_jellyfish(options)
        
        # ç»‘å®šç‚¹å‡»äº‹ä»¶ - æ·»åŠ æŒ‰å‹åé¦ˆ
        for i in range(len(self.jellyfish)):
            # ç»‘å®šæŒ‰å‹äº‹ä»¶
            self.canvas.tag_bind(f'jelly_{i}', '<ButtonPress-1>', 
                                lambda e, idx=i: self.jellyfish_manager.press_jellyfish(idx))
            
            # ç»‘å®šé‡Šæ”¾äº‹ä»¶
            self.canvas.tag_bind(f'jelly_{i}', '<ButtonRelease-1>', 
                                lambda e, idx=i, opt=options[i]: self.handle_jellyfish_release(idx, opt))
        
        # å¼€å§‹åŠ¨ç”»
        self.jellyfish_manager.animate()
    
    def handle_jellyfish_release(self, jelly_index, option):
        """å¤„ç†æ°´æ¯é‡Šæ”¾äº‹ä»¶"""
        # é‡Šæ”¾æŒ‰å‹æ•ˆæœ
        self.jellyfish_manager.release_jellyfish(jelly_index)
        # æ£€æŸ¥ç­”æ¡ˆ
        self.check_answer(option)
    
    def disable_jellyfish(self):
        """ç¦ç”¨æ‰€æœ‰æ°´æ¯ç‚¹å‡»"""
        if self.jellyfish_manager:
            self.jellyfish_manager.disable_interaction()

    def check_answer(self, selected):
        """æ£€æŸ¥ç­”æ¡ˆ"""
        # é˜²æ­¢é‡å¤ç‚¹å‡»
        if hasattr(self, '_answer_checked') and self._answer_checked:
            return
        
        self._answer_checked = True
        self.disable_jellyfish()
        
        if isinstance(self.correct_answer, tuple):
            try:
                parts = selected.split(',')
                if len(parts) != 2:
                    correct = False
                else:
                    selected_tuple = (float(parts[0]), float(parts[1]))
                    correct = (selected_tuple == self.correct_answer or
                              (selected_tuple[1], selected_tuple[0]) == self.correct_answer)
            except:
                correct = False
        else:
            try:
                correct = abs(float(selected) - float(self.correct_answer)) < 0.01
            except:
                correct = False
        
        if correct:
            self.handle_correct()
        else:
            self.handle_incorrect()

    def handle_correct(self):
        """å¤„ç†æ­£ç¡®ç­”æ¡ˆ"""
        self.controller.sound_manager.play_correct()
        
        difficulty = getattr(self.controller, 'selected_difficulty', 'Easy')
        points = LEVEL_POINTS.get(difficulty, 10)
        
        self.score += points
        self.feedback_label.config(text=f'+{points} points! Correct!', fg='green')
        self.update_status()
        
        self.after(1500, self.next_question)

    def handle_incorrect(self):
        """å¤„ç†é”™è¯¯ç­”æ¡ˆ"""
        self.controller.sound_manager.play_wrong()
        self.lives -= 1
        
        # ç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
        incorrect_messages = [
            "Oops! That's not quite right. Keep trying! ğŸ’ª",
            "Not this time, but you're learning! ğŸŒŸ",
            "Close! Don't give up, you've got this! âœ¨",
            "That's okay! Every mistake is a learning opportunity! ğŸ¯"
        ]
        
        import random
        message = random.choice(incorrect_messages)
        self.feedback_label.config(text=message, fg='orange')
        self.update_status()
        
        if self.lives <= 0:
            self.after(1500, self.game_over)
        else:
            self.after(1500, self.next_question)

    def save_and_show_leaderboard(self):
        """ä¿å­˜åˆ†æ•°å¹¶æ˜¾ç¤ºæ’è¡Œæ¦œ"""
        player_name = getattr(self.controller, 'player_name', 'Player')
        difficulty = getattr(self.controller, 'selected_difficulty', 'Easy')
        
        # å®é™…ä¿å­˜åˆ†æ•°åˆ°æ–‡ä»¶
        score_manager = ScoreManager()
        score_manager.save_result(player_name, self.score, difficulty)
        
        # ä¿å­˜ç»“æœåˆ°æ§åˆ¶å™¨ç”¨äºé«˜äº®æ˜¾ç¤º
        self.controller.last_score = {
            'player': player_name,
            'score': self.score,
            'difficulty': difficulty
        }
        
        self.controller.show_frame('LeaderboardPage')

    def game_completed(self):
        """æ¸¸æˆå®Œæˆ"""
        self._game_active = False
        self.cancel_all_timers()
        
        player_name = getattr(self.controller, 'player_name', 'Player')
        difficulty = getattr(self.controller, 'selected_difficulty', 'Easy')
        
        # ç”¨æˆ·å‹å¥½çš„å®Œæˆæ¶ˆæ¯
        completion_messages = [
            f"ğŸ‰ Amazing job, {player_name}! You're a math superstar! ğŸŒŸ",
            f"ğŸ† Fantastic work! You've conquered the {difficulty} challenge!",
            f"âœ¨ Incredible! You've mastered the {difficulty} level!",
            f"ğŸŠ Outstanding performance! You're ready for the next challenge!"
        ]
        
        import random
        message = random.choice(completion_messages)
        
        # ä½¿ç”¨è‡ªå®šä¹‰å¯¹è¯æ¡†æä¾›æ›´å¤šé€‰é¡¹
        from tkinter import simpledialog
        
        # åˆ›å»ºè‡ªå®šä¹‰å¯¹è¯æ¡†
        dialog = tk.Toplevel()
        dialog.title("ğŸ‰ Level Complete! ğŸ‰")
        dialog.geometry("500x300")
        dialog.configure(bg='#E8F4FD')
        dialog.resizable(False, False)
        
        # å±…ä¸­æ˜¾ç¤º
        dialog.transient(self)
        dialog.grab_set()
        
        # å†…å®¹
        content_frame = tk.Frame(dialog, bg='#E8F4FD')
        content_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        tk.Label(
            content_frame,
            text=message,
            font=('Comic Sans MS', 14, 'bold'),
            bg='#E8F4FD',
            fg='#2C3E50',
            wraplength=450
        ).pack(pady=10)
        
        tk.Label(
            content_frame,
            text=f"ğŸ¯ Final Score: {self.score} points\nğŸ® Difficulty: {difficulty}",
            font=('Comic Sans MS', 12),
            bg='#E8F4FD',
            fg='#006994'
        ).pack(pady=10)
        
        # æŒ‰é’®æ¡†æ¶
        button_frame = tk.Frame(content_frame, bg='#E8F4FD')
        button_frame.pack(pady=20)
        
        play_again_var = tk.StringVar(value="")
        
        def on_play_again():
            play_again_var.set("play_again")
            dialog.destroy()
        
        def on_back_menu():
            play_again_var.set("back_menu")
            dialog.destroy()
        
        def on_leaderboard():
            play_again_var.set("leaderboard")
            dialog.destroy()
        
        tk.Button(
            button_frame,
            text="ğŸ® Play Again (Same Difficulty)",
            font=('Comic Sans MS', 12, 'bold'),
            bg='#4CAF50',
            fg='white',
            padx=15,
            pady=8,
            command=on_play_again
        ).pack(side='left', padx=5)
        
        tk.Button(
            button_frame,
            text="ğŸ  Back to Menu",
                font=('Comic Sans MS', 12, 'bold'),
            bg='#FF9800',
                fg='white',
            padx=15,
            pady=8,
            command=on_back_menu
        ).pack(side='left', padx=5)
        
        tk.Button(
            button_frame,
            text="ğŸ† View Leaderboard",
            font=('Comic Sans MS', 12, 'bold'),
            bg='#2196F3',
            fg='white',
            padx=15,
            pady=8,
            command=on_leaderboard
        ).pack(side='left', padx=5)
        
        # ç­‰å¾…ç”¨æˆ·é€‰æ‹©
        dialog.wait_window()
        result = play_again_var.get()
        
        if result == "play_again":
            # ç›´æ¥é‡æ–°å¼€å§‹ç›¸åŒéš¾åº¦çš„æ¸¸æˆ
            self.reset_game()
            self.controller.show_frame('GamePage')
        elif result == "back_menu":
            # è¿”å›èœå•å¹¶é‡ç½®ç©å®¶ä¿¡æ¯
            self.reset_game()
            player_info_page = self.controller.page_frames['PlayerInfoMapPage']
            player_info_page.reset_player_info()
            self.controller.show_frame('PlayerInfoMapPage')
        else:  # leaderboard
            # æ˜¾ç¤ºæ’è¡Œæ¦œ
            self.save_and_show_leaderboard()

    def game_over(self):
        """æ¸¸æˆç»“æŸ"""
        self._game_active = False
        self.cancel_all_timers()
        
        player_name = getattr(self.controller, 'player_name', 'Player')
        
        # ç”¨æˆ·å‹å¥½çš„æ¸¸æˆç»“æŸæ¶ˆæ¯
        game_over_messages = [
            f"ğŸ’ª Don't worry, {player_name}! Every great mathematician started somewhere!",
            f"ğŸŒŸ Keep practicing, {player_name}! You're getting better with each try!",
            f"ğŸ¯ Nice effort, {player_name}! Math is a journey, not a destination!",
            f"âœ¨ Great attempt, {player_name}! Learning from mistakes makes you stronger!"
        ]
        
        import random
        message = random.choice(game_over_messages)
        
        # æ ¹æ®å½“å‰éš¾åº¦æä¾›åˆé€‚çš„å»ºè®®
        current_difficulty = getattr(self.controller, 'selected_difficulty', 'Easy')
        if current_difficulty == 'Easy':
            tip = "ğŸ’¡ Tip: Practice makes perfect! Try again to improve your score!"
        elif current_difficulty == 'Medium':
            tip = "ğŸ’¡ Tip: You're doing great! Try the Easy level to build confidence, or try Medium again!"
        else:  # Hard
            tip = "ğŸ’¡ Tip: Hard level is challenging! Try Medium or Easy to practice first!"
        
        result = messagebox.askyesno(
            "ğŸ® Game Over - But Don't Give Up! ğŸ®",
            f"{message}\n\n"
            f"ğŸ¯ Final Score: {self.score} points\n"
            f"ğŸ® Difficulty: {current_difficulty}\n"
            f"{tip}\n\n"
            f"Would you like to try again?"
        )
        
        if result:
            # ç›´æ¥é‡æ–°å¼€å§‹ç›¸åŒéš¾åº¦çš„æ¸¸æˆ
            self.reset_game()
            self.controller.show_frame('GamePage')
        else:
            # æ˜¾ç¤ºæ’è¡Œæ¦œ
            self.save_and_show_leaderboard()

game_objects file:

import tkinter as tk
import random
import math
import json
import time
import os
from utils import ScoreManager as DataManager  # å¯¼å…¥åˆ†æ•°ç®¡ç†å™¨

class JellyfishManager:
    """ç®¡ç†æ°´æ¯è®¾å®šå’Œè¡Œä¸ºçš„ç±» - ä½¿ç”¨çœŸå®æ°´æ¯å›¾ç‰‡"""
    SPEEDS = {'Easy': 7, 'Medium': 1.9, 'Hard': 1.7}  # æ°´æ¯é€Ÿåº¦è®¾ç½®
    
    def __init__(self, canvas, difficulty):
        self.canvas = canvas
        self.difficulty = difficulty
        self.jellyfish = []
        self.active_animations = []
        self.jellyfish_images = self._load_jellyfish_images()
    
    def _load_jellyfish_images(self):
        """åŠ è½½æ°´æ¯å›¾ç‰‡èµ„æº"""
        try:
            # å°è¯•åŠ è½½æ°´æ¯PNGå›¾ç‰‡
            img = tk.PhotoImage(file='assets/Images/jellyfish.png')
            return {
                'main': img.subsample(3, 3),  # ä¸»æ°´æ¯å›¾ç‰‡ - è¾ƒå°å°ºå¯¸
                'small': img.subsample(4, 4),  # æ›´å°çš„æ°´æ¯å›¾ç‰‡
                'glow': img.subsample(3, 3)    # å‘å…‰æ•ˆæœå›¾ç‰‡
            }
        except Exception as e:
            print(f"æ— æ³•åŠ è½½æ°´æ¯å›¾ç‰‡: {e}")
            return None
    
    def create_jellyfish(self, options):
        """åˆ›å»ºçœŸå®æ°´æ¯å¯¹è±¡ - ä½¿ç”¨PNGå›¾ç‰‡"""
        self.canvas.delete('all')
        self.jellyfish = []
        positions = self._calculate_positions(len(options))
        
        for i, option in enumerate(options):
            x, y = positions[i]
            
            # åˆ›å»ºæ°´æ¯ä¸»ä½“ - ä½¿ç”¨çœŸå®æ°´æ¯å›¾ç‰‡
            if self.jellyfish_images:
                jelly_id = self.canvas.create_image(
                    x, y-25,  # æ°´æ¯å›¾ç‰‡ä½ç½® - ç¨å¾®ä¸Šç§»
                    image=self.jellyfish_images['main'],
                    tags=('jellyfish', 'clickable', f'jelly_{i}')
                )
            else:
                # å¤‡ç”¨æ–¹æ¡ˆï¼šåˆ›å»ºæ›´çœŸå®çš„æ°´æ¯å½¢çŠ¶
                jelly_id = self.canvas.create_oval(
                    x-20, y-20, x+20, y+20,
                    fill='#FFE4E1',  # æ›´æŸ”å’Œçš„ç²‰è‰²
                    outline='#FFB6C1', width=2,  # æ›´æŸ”å’Œçš„è½®å»“
                    tags=('jellyfish', 'clickable', f'jelly_{i}')
                )
                
                # æ·»åŠ æ°´æ¯è§¦é¡»æ•ˆæœ
                for j in range(3):
                    tentacle_x = x + random.randint(-15, 15)
                    tentacle_y = y + 20 + j * 8
                    self.canvas.create_line(
                        x, y+15, tentacle_x, tentacle_y,
                        fill='#FFB6C1', width=2,
                        tags=('jellyfish', 'tentacle', f'jelly_{i}')
                    )
            
            # åˆ›å»ºç­”æ¡ˆæ°”æ³¡ - æµ·ç»µå®å®é£æ ¼ï¼Œæ›´å°æ›´ç²¾è‡´
            bubble = self.canvas.create_oval(
                x-30, y+15, x+30, y+70,  # æ°”æ³¡åœ¨æ°´æ¯ä¸‹æ–¹ï¼Œæ›´å°
                fill='#F4E4BC',  # æµ·ç»µå®å®è‚¤è‰²
                outline='#DAA520', width=2,  # é‡‘è‰²è¾¹æ¡†
                tags=('jellyfish', 'clickable', 'bubble', f'jelly_{i}')
            )
            
            # æ·»åŠ ç­”æ¡ˆæ–‡æœ¬ - æ›´æ¸…æ™°æ˜“è¯»
            text_id = self.canvas.create_text(
                x, y+42,  # æ–‡æœ¬åœ¨æ°”æ³¡ä¸­å¤®
                text=option, 
                font=('Arial', 14, 'bold'),  # ç¨å¾®å°ä¸€ç‚¹çš„å­—ä½“
                fill='#654321',  # æ·±æ£•è‰²æ–‡å­—
                tags=('jellyfish', 'clickable', 'bubble_text', f'jelly_{i}')
            )
            
            # æ·»åŠ æ–‡å­—é˜´å½± - å¢å¼ºå¯è¯»æ€§
            shadow_id = self.canvas.create_text(
                x+1, y+43,  # é˜´å½±åç§»
                text=option, 
                font=('Arial', 14, 'bold'),
                fill='#8B4513',  # æ·±æ£•è‰²é˜´å½±
                tags=('jellyfish', 'text_shadow', f'jelly_{i}')
            )
            
            # è®¾ç½®ç§»åŠ¨å±æ€§
            angle = random.uniform(0, 2 * math.pi)
            speed = self.SPEEDS.get(self.difficulty, 1.0)
            dx = math.cos(angle) * speed
            dy = math.sin(angle) * speed
            
            self.jellyfish.append({
                'jelly_id': jelly_id,
                'bubble': bubble,
                'text': text_id,
                'shadow': shadow_id,
                'dx': dx,
                'dy': dy,
                'x': x,
                'y': y,
                'animation_offset': random.uniform(0, 2 * math.pi),  # åŠ¨ç”»åç§»
                'pressed': False,  # æŒ‰å‹çŠ¶æ€
                'original_y': y  # åŸå§‹Yä½ç½®ç”¨äºæŒ‰å‹æ•ˆæœ
            })
        
        return self.jellyfish
    
    def animate(self):
        """åŠ¨ç”»æ°´æ¯è¿åŠ¨ - è‡ªç„¶æµç•…ï¼Œé¿å…é‡å å’Œè¾¹ç•Œé—®é¢˜"""
        width = self.canvas.winfo_width()
        height = self.canvas.winfo_height()
        
        if width < 100:
            width = 700
        if height < 100:
            height = 400
        
        # å¢åŠ è¾¹ç•Œç©ºé—´ï¼Œé¿å…æ°´æ¯è¢«åˆ‡å‰²
        boundary_height = int(height * 0.75)  # å‡å°‘æ´»åŠ¨èŒƒå›´ï¼Œç•™æ›´å¤šåº•éƒ¨ç©ºé—´
        boundary_width = width - 80  # å·¦å³å„ç•™40åƒç´ ç©ºé—´
        
        current_time = time.time()
        
        for jelly in self.jellyfish:
            # è®¡ç®—æ³¢åŠ¨æ•ˆæœ - ä½¿ç”¨åŠ¨ç”»åç§»é¿å…åŒæ­¥
            wave_x = math.sin(current_time * 0.8 + jelly['animation_offset']) * 2
            wave_y = math.cos(current_time * 1.2 + jelly['animation_offset']) * 2
            
            # æ›´æ–°ä½ç½® - åŸºç¡€ç§»åŠ¨ + æ³¢åŠ¨
            new_x = jelly['x'] + jelly['dx'] + wave_x
            new_y = jelly['y'] + jelly['dy'] + wave_y
            
            # è¾¹ç•Œæ£€æµ‹ - å¹³æ»‘åå¼¹ï¼Œç¡®ä¿æ°´æ¯å®Œå…¨å¯è§
            if new_x < 60:  # å¢åŠ å·¦è¾¹è·
                new_x = 60
                jelly['dx'] = abs(jelly['dx']) * 0.9  # å¹³æ»‘åå¼¹
            elif new_x > boundary_width:
                new_x = boundary_width
                jelly['dx'] = -abs(jelly['dx']) * 0.9  # å¹³æ»‘åå¼¹
                
            if new_y < 60:  # å¢åŠ ä¸Šè¾¹è·
                new_y = 60
                jelly['dy'] = abs(jelly['dy']) * 0.9  # å¹³æ»‘åå¼¹
            elif new_y > boundary_height:
                new_y = boundary_height
                jelly['dy'] = -abs(jelly['dy']) * 0.9  # å¹³æ»‘åå¼¹
            
            # æ›´æ–°æ°´æ¯å›¾ç‰‡ä½ç½®
            self.canvas.coords(jelly['jelly_id'], new_x, new_y-25)
            
            # æ›´æ–°æ°”æ³¡ä½ç½®
            self.canvas.coords(jelly['bubble'], 
                              new_x-30, new_y+15, 
                              new_x+30, new_y+70)
            
            # æ›´æ–°æ–‡æœ¬ä½ç½®
            self.canvas.coords(jelly['text'], new_x, new_y+42)
            self.canvas.coords(jelly['shadow'], new_x+1, new_y+43)
            
            # ç¢°æ’æ£€æµ‹ - é¿å…æ°´æ¯é‡å 
            min_distance = 100  # æœ€å°è·ç¦»
            for other_jelly in self.jellyfish:
                if other_jelly != jelly:
                    dx = new_x - other_jelly['x']
                    dy = new_y - other_jelly['y']
                    distance = math.sqrt(dx*dx + dy*dy)
                    
                    if distance < min_distance:
                        # å¦‚æœå¤ªè¿‘ï¼Œç¨å¾®æ¨å¼€
                        if distance > 0:
                            push_x = (dx / distance) * (min_distance - distance) * 0.5
                            push_y = (dy / distance) * (min_distance - distance) * 0.5
                            new_x += push_x
                            new_y += push_y
                            
                            # ç¡®ä¿æ¨å¼€çš„è·ç¦»ä»åœ¨è¾¹ç•Œå†…
                            new_x = max(60, min(boundary_width, new_x))
                            new_y = max(60, min(boundary_height, new_y))
            
            # ä¿å­˜æ–°ä½ç½®
            jelly['x'] = new_x
            jelly['y'] = new_y
        
        # ç»§ç»­åŠ¨ç”»å¾ªç¯ - 30fps
        anim_id = self.canvas.after(30, self.animate)
        self.active_animations.append(anim_id)
    
    def stop_animations(self):
        """åœæ­¢æ‰€æœ‰åŠ¨ç”»"""
        for anim_id in self.active_animations:
            try:
                self.canvas.after_cancel(anim_id)
            except:
                pass
        self.active_animations = []
    
    def disable_interaction(self):
        """ç¦ç”¨æ‰€æœ‰æ°´æ¯äº¤äº’"""
        self.canvas.tag_unbind('clickable', '<Button-1>')
        self.canvas.tag_unbind('clickable', '<ButtonPress-1>')
        self.canvas.tag_unbind('clickable', '<ButtonRelease-1>')
    
    def press_jellyfish(self, jelly_index):
        """æŒ‰å‹æ°´æ¯æ•ˆæœ - è§†è§‰åé¦ˆ"""
        if 0 <= jelly_index < len(self.jellyfish):
            jelly = self.jellyfish[jelly_index]
            if not jelly['pressed']:
                jelly['pressed'] = True
                # ç§»åŠ¨æ°´æ¯å‘ä¸‹ï¼Œæ¨¡æ‹ŸæŒ‰å‹æ•ˆæœ - æ›´æ˜æ˜¾çš„ç§»åŠ¨
                self.canvas.coords(jelly['jelly_id'], jelly['x'], jelly['y']-20)
                self.canvas.coords(jelly['bubble'], 
                                 jelly['x']-30, jelly['y']+15, 
                                 jelly['x']+30, jelly['y']+70)
                self.canvas.coords(jelly['text'], jelly['x'], jelly['y']+42)
                self.canvas.coords(jelly['shadow'], jelly['x']+1, jelly['y']+43)
                
                # æ·»åŠ å‘å…‰æ•ˆæœ - æ›´æ˜æ˜¾çš„é¢œè‰²å˜åŒ–
                self.canvas.itemconfig(jelly['bubble'], fill='#FFD700', outline='#FFA500', width=4)
                
                # æ·»åŠ æ–‡æœ¬é«˜äº®æ•ˆæœ
                self.canvas.itemconfig(jelly['text'], fill='#8B0000', font=('Arial', 16, 'bold'))
                self.canvas.itemconfig(jelly['shadow'], fill='#4B0082', font=('Arial', 16, 'bold'))
                
                # æ·»åŠ æ°´æ¯å›¾ç‰‡ç¼©æ”¾æ•ˆæœï¼ˆå¦‚æœä½¿ç”¨å›¾ç‰‡ï¼‰
                if self.jellyfish_images:
                    # ç¨å¾®æ”¾å¤§æ°´æ¯å›¾ç‰‡
                    self.canvas.scale(jelly['jelly_id'], jelly['x'], jelly['y']-20, 1.1, 1.1)
    
    def release_jellyfish(self, jelly_index):
        """é‡Šæ”¾æ°´æ¯æ•ˆæœ - æ¢å¤åŸä½ç½®"""
        if 0 <= jelly_index < len(self.jellyfish):
            jelly = self.jellyfish[jelly_index]
            if jelly['pressed']:
                jelly['pressed'] = False
                # æ¢å¤æ°´æ¯åˆ°åŸä½ç½®
                self.canvas.coords(jelly['jelly_id'], jelly['x'], jelly['y']-25)
                self.canvas.coords(jelly['bubble'], 
                                 jelly['x']-30, jelly['y']+15, 
                                 jelly['x']+30, jelly['y']+70)
                self.canvas.coords(jelly['text'], jelly['x'], jelly['y']+42)
                self.canvas.coords(jelly['shadow'], jelly['x']+1, jelly['y']+43)
                
                # æ¢å¤æ°”æ³¡é¢œè‰²
                self.canvas.itemconfig(jelly['bubble'], fill='#F4E4BC', outline='#DAA520', width=2)
                
                # æ¢å¤æ–‡æœ¬æ ·å¼
                self.canvas.itemconfig(jelly['text'], fill='#654321', font=('Arial', 14, 'bold'))
                self.canvas.itemconfig(jelly['shadow'], fill='#8B4513', font=('Arial', 14, 'bold'))
                
                # æ¢å¤æ°´æ¯å›¾ç‰‡ç¼©æ”¾ï¼ˆå¦‚æœä½¿ç”¨å›¾ç‰‡ï¼‰
                if self.jellyfish_images:
                    # æ¢å¤æ°´æ¯å›¾ç‰‡å¤§å°
                    self.canvas.scale(jelly['jelly_id'], jelly['x'], jelly['y']-25, 1.0, 1.0)
    
    def _calculate_positions(self, count):
        """è®¡ç®—æ°´æ¯åˆå§‹ä½ç½® - é¿å…é‡å """
        width = max(self.canvas.winfo_width(), 700)
        height = min(max(self.canvas.winfo_height(), 400), 400) * 0.7
    
        if count == 1:
            return [(width // 2, height // 2)]

        positions = []
        center_x, center_y = width // 2, height // 2
        
        # æ ¹æ®æ°´æ¯æ•°é‡è°ƒæ•´åŠå¾„ï¼Œç¡®ä¿è¶³å¤Ÿé—´è·
        if count == 2:
            radius = min(width, height) * 0.25  # 2ä¸ªæ°´æ¯æ—¶ä½¿ç”¨è¾ƒå°åŠå¾„
        elif count == 3:
            radius = min(width, height) * 0.3   # 3ä¸ªæ°´æ¯æ—¶ä½¿ç”¨ä¸­ç­‰åŠå¾„
        else:
            radius = min(width, height) * 0.35  # 4ä¸ªæ°´æ¯æ—¶ä½¿ç”¨è¾ƒå¤§åŠå¾„
    
        for i in range(count):
            angle = 2 * math.pi * i / count
            x = center_x + radius * math.cos(angle)
            y = center_y + radius * math.sin(angle)
            
            # æ·»åŠ éšæœºåç§»ï¼Œé¿å…å®Œå…¨é‡å 
            import random
            x += random.randint(-20, 20)
            y += random.randint(-20, 20)
        
            # ç¡®ä¿åœ¨å®‰å…¨è¾¹ç•Œå†…
            x = max(80, min(width - 80, x))
            y = max(80, min(height - 80, y))
        
            positions.append((x, y))
    
        return positions


# ç§»é™¤CharacterManagerç±» - ä¸å†éœ€è¦è§’è‰²é€‰æ‹©åŠŸèƒ½


class LeaderboardPage(tk.Frame):
    """æ’è¡Œæ¦œé¡µé¢"""
    def __init__(self, parent, controller):
        super().__init__(parent, bg='#f0f8ff')
        self.controller = controller
        self._create_widgets()
    
    def _create_widgets(self):
        """åˆ›å»ºUIå…ƒç´ """
        # ä¸»æ¡†æ¶ - æ¸å˜èƒŒæ™¯æ•ˆæœ
        self.config(bg='#E8F4FD')  # æµ·æ´‹è“èƒŒæ™¯
        main_frame = tk.Frame(self, bg='#E8F4FD')
        main_frame.pack(fill='both', expand=True, padx=15, pady=15)
        
        # æ·»åŠ è£…é¥°æ€§è¾¹æ¡†
        border_frame = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        border_frame.pack(fill='both', expand=True, padx=5, pady=5)
        
        # å†…å®¹æ¡†æ¶
        content_frame = tk.Frame(border_frame, bg='#F0F8FF')
        content_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # æ ‡é¢˜æ¡†æ¶
        title_frame = tk.Frame(content_frame, bg='#F0F8FF')
        title_frame.pack(pady=10)
        
        tk.Label(
            title_frame, 
            text='ğŸ† Bikini Bottom Hall of Fame',
            font=('Comic Sans MS', 24, 'bold'),
            bg='#F0F8FF', 
            fg='#006994'
        ).pack(pady=10)
        
        self.leaderboard_frame = tk.Frame(content_frame, bg='#f0f8ff', bd=3, relief='groove')
        self.leaderboard_frame.pack(side='top', pady=10, fill='both', expand=True)
        
        menu_btn = tk.Button(
            content_frame, 
            text='ğŸ  Main Menu', 
            font=('Comic Sans MS', 14, 'bold'),
            bg='#FFD700', 
            fg='#2C3E50',
            padx=15,
            pady=8,
            relief='raised',
            bd=2,
            command=lambda: self.controller.show_frame('StartPage')
        )
        menu_btn.pack(side='bottom', pady=10)
        
        self.refresh()

    def refresh(self):
        """åˆ·æ–°æ’è¡Œæ¦œæ˜¾ç¤º"""
        for widget in self.leaderboard_frame.winfo_children():
            widget.destroy()
        
        header = tk.Frame(self.leaderboard_frame, bg='#5a9')
        header.pack(fill='x', pady=(0, 5))
        
        headers = ['Rank', 'Name', 'Score', 'Difficulty']
        widths = [8, 20, 10, 15]
        
        for i, h in enumerate(headers):
            tk.Label(
                header, 
                text=h, 
                font=('Comic Sans MS', 12, 'bold'),
                bg='#5a9', 
                fg='white',
                width=widths[i]
            ).grid(row=0, column=i, padx=2, sticky='ew')
        
        scores = DataManager().get_records()
        
        if not scores:
            no_scores = tk.Label(
                self.leaderboard_frame,
                text='No scores yet! Be the first to play!',
                font=('Comic Sans MS', 16),
                bg='#f0f8ff',
                pady=50
            )
            no_scores.pack(fill='both', expand=True)
            return
        
        scores_container = tk.Canvas(self.leaderboard_frame, bg='#f0f8ff', highlightthickness=0)
        scrollbar = tk.Scrollbar(self.leaderboard_frame, orient='vertical', command=scores_container.yview)
        scrollable_frame = tk.Frame(scores_container, bg='#f0f8ff')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: scores_container.configure(scrollregion=scores_container.bbox("all"))
        )
        scores_container.create_window((0, 0), window=scrollable_frame, anchor="nw")
        scores_container.configure(yscrollcommand=scrollbar.set)
        
        scores_container.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
        
        highlight_index = -1
        if hasattr(self.controller, 'last_score') and self.controller.last_score is not None:
            player_score = self.controller.last_score
            
            for i, score in enumerate(scores):
                score_player = score.get('player', score.get('name', 'Unknown'))
                player_name = player_score.get('player', player_score.get('name', 'Player'))
                
                score_value = score.get('score', 0)
                player_value = player_score.get('score', 0)
                
                score_difficulty = score.get('difficulty', score.get('level', 'Easy'))
                player_difficulty = player_score.get('difficulty', 'Easy')
                
                if (score_player == player_name and 
                    score_value == player_value and 
                    score_difficulty == player_difficulty):
                    highlight_index = i
                    break
        
        prev_score = None
        rank = 0
        skip = 0
        
        for i, score in enumerate(scores[:10]):
            current_score = score.get('score', 0)
            current_difficulty = score.get('difficulty', score.get('level', 'Easy'))
            
            if prev_score is None:
                prev_score = score
                rank = 1
                skip = 0
            else:
                prev_score_value = prev_score.get('score', 0)
                prev_difficulty = prev_score.get('difficulty', prev_score.get('level', 'Easy'))
                
                if current_score != prev_score_value or current_difficulty != prev_difficulty:
                    rank += 1 + skip
                    skip = 0
                else:
                    skip += 1
            
            if i == highlight_index:
                bg_color = '#FFD700'  # é‡‘è‰²é«˜äº®
            elif i % 2 == 0:
                bg_color = '#e6f7ff'
            else:
                bg_color = '#f0f8ff'
            
            row = tk.Frame(scrollable_frame, bg=bg_color)
            row.pack(fill='x', pady=2)
            
            tk.Label(
                row, 
                text=str(rank), 
                font=('Comic Sans MS', 12),
                bg=bg_color, 
                width=widths[0]
            ).grid(row=0, column=0)
            
            player_name = score.get('player', score.get('name', 'Unknown'))
            tk.Label(
                row, 
                text=player_name, 
                font=('Comic Sans MS', 12),
                bg=bg_color, 
                width=widths[1]
            ).grid(row=0, column=1)
            
            tk.Label(
                row, 
                text=str(score.get('score', 0)), 
                font=('Comic Sans MS', 12),
                bg=bg_color, 
                width=widths[2]
            ).grid(row=0, column=2)
            
            difficulty = score.get('difficulty', score.get('level', 'Easy'))
            tk.Label(
                row, 
                text=difficulty, 
                font=('Comic Sans MS', 12),
                bg=bg_color, 
                width=widths[3]
            ).grid(row=0, column=3)
            
            prev_score = score

utils file:

import random
import json
import os
import time

# Try to import pygame for sound effects, but don't crash if it's not available
try:
    import pygame
    pygame_works = True
except ImportError:
    pygame_works = False
    print("pygame not found - sound will be turned off")

class ProblemGenerator:
    """Makes math problems fun with SpongeBob stuff"""
    
    def __init__(self, difficulty='Easy'):
        self.difficulty = difficulty
        # Stuff from the show to make problems interesting
        self.people = ['SpongeBob', 'Patrick', 'Squidward', 'Mr. Krabs', 'Sandy']
        self.stuff = ['Krabby Patty', 'jellyfish', 'bubble', 'pineapple', 'treasure chest', 
                     'karate glove', 'kite', 'net', 'spatula', 'money']
        self.places = ['Bikini Bottom', 'Jellyfish Fields', 'Krusty Krab', 'Pineapple House', 
                         'Rock Bottom', 'Goo Lagoon', 'Chum Bucket']

    def create_problem(self):
        """Makes a math problem with SpongeBob theme and gives you choices to pick from"""
        if self.difficulty == 'Easy':
            problem, answer = self._make_easy_one()
        elif self.difficulty == 'Medium':
            problem, answer = self._make_medium_one()
        else:
            problem, answer = self._make_hard_one()
        
        choices = self._make_choices(answer)
        return problem, answer, choices

    def _make_easy_one(self):
        """Easy problems for beginners"""
        what_kind = random.choice(['math', 'counting', 'money'])
        
        if what_kind == 'math':
            return self._basic_math()
        elif what_kind == 'counting':
            return self._counting_stuff()
        else:
            return self._money_stuff()

    def _basic_math(self):
        """Simple adding, subtracting, multiplying with SpongeBob things"""
        num1 = random.randint(1, 12)
        num2 = random.randint(1, 12)
        what_to_do = random.choice(['+', '-', 'x'])
        
        if what_to_do == 'x':
            result = num1 * num2
            thing = random.choice(self.stuff)
            problem = f"SpongeBob has {num1} {thing}s. If he gets {num2} times more, how many {thing}s does he have now?"
        elif what_to_do == '+':
            result = num1 + num2
            thing1, thing2 = random.sample(self.stuff, 2)
            problem = f"Patrick found {num1} {thing1}s and {num2} {thing2}s. How many things did he find in total?"
        else:  # subtraction
            result = num1 - num2
            thing = random.choice(self.stuff)
            problem = f"Mr. Krabs had {num1} {thing}s. He sold {num2} of them. How many {thing}s does he have left?"
        
        return problem, result

    def _counting_stuff(self):
        """Counting problems with characters"""
        person = random.choice(self.people)
        thing = random.choice(self.stuff)
        how_many = random.randint(3, 15)
        
        problem = f"{person} is collecting {thing}s. He already has {how_many} {thing}s. "
        if random.choice([True, False]):
            # Adding more
            extra = random.randint(1, 8)
            result = how_many + extra
            problem += f"If he finds {extra} more {thing}s, how many {thing}s will he have?"
        else:
            # Taking some away
            less = random.randint(1, min(how_many-1, 5))
            result = how_many - less
            problem += f"If he gives away {less} {thing}s, how many {thing}s will he have left?"
        
        return problem, result

    def _money_stuff(self):
        """Money problems at the Krusty Krab"""
        cost = random.randint(2, 8)
        how_many = random.randint(1, 10)
        total = cost * how_many
        
        problem = f"A Krabby Patty costs ${cost}. If you buy {how_many} Krabby Patties, how much do you pay in total?"
        return problem, total

    def _make_medium_one(self):
        """Medium problems - a bit harder"""
        what_kind = random.choice(['equation', 'percent', 'sequence'])
        
        if what_kind == 'equation':
            return self._equation_problem()
        elif what_kind == 'percent':
            return self._percent_problem()
        else:
            return self._sequence_problem()

    def _equation_problem(self):
        """Simple equations like 2x + 3 = 11"""
        x = random.randint(2, 15)
        a = random.randint(1, 5)
        b = random.randint(1, 10)
        
        # Make sure the equation makes sense
        result = a * x + b
        person = random.choice(self.people)
        thing = random.choice(self.stuff)
        
        problem = f"{person} has {a} {thing}s. If someone gives him {b} more {thing}s, he now has {result} {thing}s. How many {thing}s did he have at first?"
        return problem, x

    def _percent_problem(self):
        """Percentage problems"""
        percent = random.choice([10, 20, 25, 50, 75])
        original = random.randint(10, 100)
        new_amount = int(original * (1 + percent/100))
        
        person = random.choice(self.people)
        thing = random.choice(self.stuff)
        
        problem = f"{person} had {original} {thing}s. After a {percent}% increase, he now has {new_amount} {thing}s. What was the original number?"
        return problem, original

    def _sequence_problem(self):
        """Find the next number in a pattern"""
        start = random.randint(1, 10)
        step = random.randint(2, 8)
        
        # Make a sequence: start, start+step, start+2*step, start+3*step, ?
        sequence = [start, start + step, start + 2*step, start + 3*step]
        answer = start + 4*step
        
        person = random.choice(self.people)
        thing = random.choice(self.stuff)
        
        problem = f"{person} is counting {thing}s: {sequence[0]}, {sequence[1]}, {sequence[2]}, {sequence[3]}, ... What comes next?"
        return problem, answer

    def _make_hard_one(self):
        """Hard problems for smart people"""
        what_kind = random.choice(['quadratic', 'system', 'geometry'])
        
        if what_kind == 'quadratic':
            return self._quadratic_problem()
        elif what_kind == 'system':
            return self._system_problem()
        else:
            return self._geometry_problem()

    def _quadratic_problem(self):
        """Quadratic equations that factor nicely"""
        # Pick nice numbers that work well together
        x1 = random.randint(2, 8)
        x2 = random.randint(2, 8)
        
        # Make sure they're different
        if x1 == x2:
            x2 = random.randint(9, 12)
        
        # (x - x1)(x - x2) = x^2 - (x1+x2)x + x1*x2
        a = 1
        b = -(x1 + x2)
        c = x1 * x2
        
        # Pick one of the roots as the answer
        answer = random.choice([x1, x2])
        
        person = random.choice(self.people)
        thing = random.choice(self.stuff)
        
        problem = f"{person} is solving: xÂ² + {b}x + {c} = 0. One solution is x = {answer}. What's the other solution?"
        # Return the other root
        other_answer = x1 if answer == x2 else x2
        return problem, other_answer

    def _system_problem(self):
        """System of two equations"""
        # Make simple equations that are easy to solve
        x = random.randint(2, 8)
        y = random.randint(2, 8)
        
        # x + y = something, x - y = something else
        sum_xy = x + y
        diff_xy = x - y
        
        person1, person2 = random.sample(self.people, 2)
        thing1, thing2 = random.sample(self.stuff, 2)
        
        problem = f"{person1} has x {thing1}s and y {thing2}s. {person2} has the same x {thing1}s but different y {thing2}s. "
        problem += f"Together they have {sum_xy} items, but the difference is {diff_xy}. What is x?"
        
        return problem, x

    def _geometry_problem(self):
        """Simple area or perimeter problems"""
        what_kind = random.choice(['area', 'perimeter'])
        
        if what_kind == 'area':
            length = random.randint(3, 10)
            width = random.randint(3, 10)
            area = length * width
            
            person = random.choice(self.people)
            thing = random.choice(self.stuff)
            
            problem = f"{person} has a {thing} garden that is {length} feet long and {width} feet wide. What's the area in square feet?"
            return problem, area
        else:
            # Perimeter
            side = random.randint(4, 12)
            perimeter = 4 * side
            
            person = random.choice(self.people)
            thing = random.choice(self.stuff)
            
            problem = f"{person} has a square {thing} box with sides of {side} inches. What's the perimeter in inches?"
            return problem, perimeter

    def _make_choices(self, correct_answer):
        """Makes 4 choices, one correct and three wrong ones"""
        choices = [correct_answer]
        
        # Add some wrong answers that make sense
        if correct_answer > 0:
            # Common mistakes: off by 1, off by 10, double, half
            wrong1 = correct_answer + 1
            wrong2 = correct_answer + 10
            wrong3 = correct_answer * 2
            wrong4 = correct_answer // 2 if correct_answer > 1 else correct_answer + 5
            
            # Pick 3 different wrong answers
            wrong_answers = list(set([wrong1, wrong2, wrong3, wrong4]))
            wrong_answers = wrong_answers[:3]  # Take first 3
            
            choices.extend(wrong_answers)
        
        # If we don't have 4 choices yet, add some random ones
        while len(choices) < 4:
            random_wrong = correct_answer + random.randint(-10, 20)
            if random_wrong != correct_answer and random_wrong not in choices:
                choices.append(random_wrong)
        
        # Shuffle them up
        random.shuffle(choices)
        return choices


class ScoreManager:
    """Handles saving and loading high scores"""
    
    def __init__(self, filename='highscores.json'):
        self.filename = filename
        self._make_file_if_needed()
    
    def _make_file_if_needed(self):
        """Creates the file if it doesn't exist"""
        if not os.path.exists(self.filename):
            with open(self.filename, 'w') as f:
                json.dump([], f)
    
    def save_result(self, name, points, difficulty):
        """Saves a new score to the file"""
        # Clean up the name first
        clean_name = self._clean_name(name)
        
        # Make the new record
        new_record = {
            'player': clean_name,
            'score': points,
            'difficulty': difficulty,
            'date': time.strftime('%Y-%m-%d %H:%M:%S')
        }
        
        # Read existing scores
        try:
            with open(self.filename, 'r') as f:
                records = json.load(f)
        except:
            records = []
        
        # Add the new one
        records.append(new_record)
        
        # Sort by score (highest first)
        records.sort(key=lambda x: x['score'], reverse=True)
        
        # Keep only top 50 scores
        records = records[:50]
        
        # Save back to file
        try:
            with open(self.filename, 'w') as f:
                json.dump(records, f, indent=2)
        except Exception as e:
            print(f"Couldn't save score: {e}")
    
    def _clean_name(self, name):
        """Makes sure the name is safe to save"""
        # Remove any weird characters, keep only letters, numbers, spaces
        clean = ''.join(c for c in name if c.isalnum() or c.isspace())
        return clean.strip()[:20]  # Limit to 20 characters
    
    def get_records(self):
        """Gets all the saved scores"""
        try:
            with open(self.filename, 'r') as f:
                return json.load(f)
        except:
            return []


class AudioManager:
    """Handles all the sounds in the game"""
    
    def __init__(self):
        self.sounds_work = False
        if not pygame_works:
            print("Sound is turned off - pygame not available")
            return
        
        try:
            pygame.mixer.init()
            self.sounds_work = True
            self._load_sounds()
        except Exception as e:
            print(f"Couldn't start sound: {e}")
            self.sounds_work = False
    
    def _load_sounds(self):
        """Loads all the sound files"""
        if not pygame_works:
            return
        
        try:
            # Try to load background music
            pygame.mixer.music.load('assets/Sounds/bgm.wav')
            self.music_on = True
        except:
            self.music_on = False
        
        try:
            # Load sound effects
            self.correct_sound = pygame.mixer.Sound('assets/Sounds/correct.wav')
            self.wrong_sound = pygame.mixer.Sound('assets/Sounds/wrong.wav')
        except:
            self.correct_sound = None
            self.wrong_sound = None
    
    def toggle_music(self):
        """Turns music on or off"""
        if not pygame_works or not self.sounds_work:
            return False
        
        try:
            if self.music_on:
                pygame.mixer.music.pause()
                self.music_on = False
            else:
                pygame.mixer.music.unpause()
                self.music_on = True
            return True
        except:
            return False
    
    def play_correct(self):
        """Plays the happy sound when you get it right"""
        if pygame_works and self.sounds_work:
            try:
                self.correct_sound.play()
            except:
                pass
    
    def play_wrong(self):
        """Plays the sad sound when you get it wrong"""
        if pygame_works and self.sounds_work:
            try:
                self.wrong_sound.play()
            except:
                pass
    
    def stop_bg_music(self):
        """Stops the background music"""
        if pygame_works and self.sounds_work:
            try:
                pygame.mixer.music.stop()
            except:
                pass
    
    def cleanup(self):
        """Cleans up when the game ends"""
        if pygame_works and self.sounds_work:
            try:
                pygame.mixer.quit()
            except:
                pass
