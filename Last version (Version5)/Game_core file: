import tkinter as tk
from tkinter import messagebox
from utils import ProblemGenerator as ProblemBank, ScoreManager
from game_objects import JellyfishManager

# game settings - these control how the game works
QUESTIONS_PER_GAME = 10  # reduced questions to make it easier
# giving more time per question so players can think better
TIME_PER_QUESTION = {'Easy': 120, 'Medium': 100, 'Hard': 85}
LEVEL_NAMES = {
    'Easy': "Jellyfish Fields",
    'Medium': "Krusty Krab", 
    'Hard': "Squidward's House"
}
LEVEL_POINTS = {'Easy': 50, 'Medium': 100, 'Hard': 300}
BACKGROUND_COLORS = {
    'Easy': '#88cfff',
    'Medium': '#ff9966',
    'Hard': '#9b59b6'
}

STATUS_BAR_COLOR = '#3A6EA5'
TEXT_COLOR = '#2C3E50'

class StartPage(tk.Frame):
    def __init__(self, parent, controller):
        super().__init__(parent, bg='#76deee')
        self.controller = controller
        self._create_widgets()
    
    def _create_widgets(self):
        # try to load background image - this might fail sometimes
        try:
            bg_image = tk.PhotoImage(file='assets/Images/bg_menu.png')
            bg_label = tk.Label(self, image=bg_image)
            bg_label.image = bg_image  # need to keep reference or it disappears
            bg_label.place(x=0, y=0, relwidth=1, relheight=1)
        except:
            # if image fails, just use a solid color
            self.config(bg='#82d4ed')
        
        title_frame = tk.Frame(self, bg='#76deee')
        title_frame.place(relx=0.5, rely=0.2, anchor='center')
        
        # button styling
        btn_style = {
            'font': ('Comic Sans MS', 18),
            'bg': '#FFD700', 
            'fg': 'black',
            'activebackground': '#FFA500',
            'relief': 'raised', 
            'bd': 3,
            'width': 13,
            'pady': 7
        }
        
        btn_frame = tk.Frame(self, bg="#76deee")
        btn_frame.place(relx=0.5, rely=0.5, anchor='center')
        
        tk.Button(
            btn_frame, 
            text='Start Game', 
            **btn_style,
            command=lambda: self.controller.show_frame('PlayerInfoMapPage')
        ).pack(pady=10)
        
        tk.Button(
            btn_frame, 
            text='Leaderboard', 
            **btn_style,
            command=lambda: self.controller.show_frame('LeaderboardPage')
        ).pack(pady=10)
        
        tk.Button(
            btn_frame, 
            text='Exit Game', 
            **btn_style,
            command=self.controller.destroy
        ).pack(pady=10)
        
        # music button - check if music is playing
        try:
            if self.controller.sound_manager.music_on:
                music_text = 'üéµ MUSIC ON'
            else:
                music_text = 'üîá MUSIC OFF'
        except:
            music_text = 'üîá MUSIC OFF'  # default to off if something goes wrong
            
        self.music_btn = tk.Button(
            self, 
            text=music_text,
            font=('Comic Sans MS', 10, 'bold'), 
            bg="#AAFF00", 
            fg='#2C3E50',
            bd=1,
            relief='raised',
            padx=4,
            pady=2,
            command=self.toggle_music
        )
        self.music_btn.place(x=620, y=10)
        
    def toggle_music(self):
        try:
            music_on = self.controller.sound_manager.toggle_music()
            if music_on:
                music_text = 'üéµ MUSIC ON'
            else:
                music_text = 'üîá MUSIC OFF'
            self.music_btn.config(text=music_text)
        except Exception as e:
            music_text = 'üîá MUSIC OFF'
            self.music_btn.config(text=music_text)
            print(f"Music toggle failed: {e}")  # debug info

class PlayerInfoMapPage(tk.Frame):
    def __init__(self, parent, controller):
        super().__init__(parent, bg='#FFE4B5')
        self.controller = controller
        self._create_widgets()
        self.name_confirmed = False
    
    def _create_widgets(self):
        # this creates all the stuff on the page
        # Title area - where the welcome message goes
        title_frame = tk.Frame(self, bg='#FFE4B5')
        title_frame.place(relx=0.5, rely=0.05, anchor='center')
        
        # Welcome decorations
        welcome_frame = tk.Frame(title_frame, bg='#FFE4B5')
        welcome_frame.pack(pady=5)
        
        tk.Label(
            welcome_frame, 
            text='üåü Welcome to Bikini Bottom! üåü',
            font=('Comic Sans MS', 18, 'bold'),
            bg='#FFE4B5', 
            fg='#FFD700'
        ).pack()
        
        tk.Label(
            welcome_frame, 
            text='üêô Ready for a math adventure? üêô',
            font=('Comic Sans MS', 14),
            bg='#FFE4B5', 
            fg='#006994'
        ).pack(pady=5)
        
        # User info form - where player enters their name
        form_frame = tk.Frame(self, bg='#FFD700', bd=5, relief='groove')
        form_frame.place(relx=0.5, rely=0.2, anchor='center', width=400, height=250)
        
        # Username input
        tk.Label(
            form_frame, 
            text="Enter Your Username: üßΩ", 
            bg='#FFD700',
            font=('Comic Sans MS', 14, 'bold'),
            fg='#2C3E50'
        ).pack(pady=5)
        
        # Hint text
        tk.Label(
            form_frame,
            text='(Pick a fun username, 3-15 characters)',
            bg='#FFD700',
            font=('Comic Sans MS', 10),
            fg='#666666'
        ).pack(pady=2)
        
        self.name_var = tk.StringVar()
        name_entry = tk.Entry(
            form_frame, 
            textvariable=self.name_var, 
            font=('Comic Sans MS', 12), 
            width=25,
            relief='sunken',
            bd=2
        )
        name_entry.pack(pady=5)
        name_entry.focus_set()
        
        # validation label - shows if name is ok or not
        self.name_validation_label = tk.Label(
            form_frame,
            text='',
            bg='#FFD700',
            font=('Comic Sans MS', 10),
            fg='red'
        )
        self.name_validation_label.pack(pady=2)
        
        # Confirm button
        confirm_btn = tk.Button(
            form_frame, 
            text='Confirm Name', 
            font=('Comic Sans MS', 12),
            bg='#4CAF50', 
            fg='white',
            padx=10,
            pady=5,
            command=self.confirm_name
        )
        confirm_btn.pack(pady=10)
        
        # Map title - where we show the difficulty choices
        map_title_frame = tk.Frame(self, bg='#FFE4B5')
        map_title_frame.place(relx=0.5, rely=0.4, anchor='center')
        
        # Decorative elements
        decoration_frame = tk.Frame(map_title_frame, bg='#FFE4B5')
        decoration_frame.pack(pady=5)
        
        tk.Label(
            decoration_frame, 
            text='‚≠ê üêö ‚≠ê',
            font=('Comic Sans MS', 16),
            bg='#FFE4B5', 
            fg='#FFD700'
        ).pack()
        
        tk.Label(
            map_title_frame, 
            text='üó∫Ô∏è Choose Your Difficulty:',
            font=('Comic Sans MS', 22, 'bold'),
            bg='#FFE4B5', 
            fg='#006994'
        ).pack(pady=5)
        
        tk.Label(
            map_title_frame, 
            text='üéÆ Click on a location to start your math journey!',
            font=('Comic Sans MS', 12),
            bg='#FFE4B5', 
            fg='#666666'
        ).pack(pady=5)
        
        # More decorations
        tk.Label(
            decoration_frame, 
            text='‚≠ê üêö ‚≠ê',
            font=('Comic Sans MS', 16),
            bg='#FFE4B5', 
            fg='#FFD700'
        ).pack()
        
        # Map selection frame - this holds the difficulty buttons
        map_frame = tk.Frame(self, bg='#FFE4B5')
        map_frame.place(relx=0.5, rely=0.65, anchor='center')
        
        # Level descriptions and colors - each difficulty has its own info
        level_info = [
            ("üåä Jellyfish Fields\n\nüéØ Easy Difficulty\nüíé 50 points per question\n\nüêô Perfect for beginners!", '#87CEEB', 'Easy', 'üêô'),
            ("üçî Krusty Krab\n\n‚ö° Medium Difficulty\nüíé 100 points per question\n\nü¶Ä For experienced players!", '#FFB347', 'Medium', 'ü¶Ä'),
            ("üé® Squidward's House\n\nüî• Hard Difficulty\nüíé 300 points per question\n\nüé∑ Ultimate challenge!", '#DDA0DD', 'Hard', 'üé∑')
        ]
        
        for i, (desc, color, level, emoji) in enumerate(level_info):
            # Create button container - each difficulty gets its own button
            btn_container = tk.Frame(map_frame, bg=color, bd=5, relief='raised')
            btn_container.grid(row=0, column=i, padx=20, pady=15)
            
            # Add decorative border
            border_frame = tk.Frame(btn_container, bg='#FFD700', bd=3, relief='sunken')
            border_frame.pack(fill='both', expand=True, padx=4, pady=4)
            
            level_btn = tk.Button(
                border_frame, 
                text=f"{emoji}\n{desc}",
                font=('Comic Sans MS', 14, 'bold'),
                bg=color, 
                fg='white', 
                width=22, 
                height=8,
                relief='flat',
                bd=0,
                activebackground='#FFD700',
                activeforeground='#2C3E50',
                cursor='hand2',
                command=lambda l=level: self.start_level(l)
            )
            level_btn.pack(fill='both', expand=True, padx=3, pady=3)
        
        # Button frame - bottom buttons for navigation
        button_frame = tk.Frame(self, bg='#FFE4B5')
        button_frame.place(relx=0.5, rely=0.92, anchor='center')
        
        # New player button - lets you start over
        new_player_btn = tk.Button(
            button_frame, 
            text='üë§ New Player', 
            font=('Comic Sans MS', 12, 'bold'),
            bg='#4CAF50', 
            fg='white',
            padx=12,
            pady=6,
            relief='raised',
            bd=3,
            command=self.reset_player_info
        )
        new_player_btn.pack(side='left', padx=10)
        
        # Instruction button
        instruction_btn = tk.Button(
            button_frame, 
            text='üìñ Instructions', 
            font=('Comic Sans MS', 12, 'bold'),
            bg='#4CAF50', 
            fg='white',
            padx=12,
            pady=6,
            relief='raised',
            bd=3,
            command=lambda: self.controller.show_frame('InstructionPage')
        )
        instruction_btn.pack(side='left', padx=10)
        
        # Main menu button
        menu_btn = tk.Button(
            button_frame, 
            text='üè† Main Menu', 
            font=('Comic Sans MS', 12, 'bold'),
            bg='#FFD700', 
            fg='#2C3E50',
            padx=12,
            pady=6,
            relief='raised',
            bd=3,
            command=lambda: self.controller.show_frame('StartPage')
        )
        menu_btn.pack(side='left', padx=10)
        
        # Status label - tells player what to do
        self.status_label = tk.Label(
            self, 
            text='Please enter and confirm your name first',
            font=('Comic Sans MS', 12),
            bg='#FFE4B5',
            fg='#2C3E50'
        )
        self.status_label.place(relx=0.5, rely=0.32, anchor='center')
        
        # Add floating decorations - makes it look pretty
        self._add_floating_decorations()

    def confirm_name(self):
        name = self.name_var.get().strip()
        
        self.name_validation_label.config(text='')
        
        # check if name is empty
        if not name:
            self.name_validation_label.config(text='‚ùå Name cannot be empty!', fg='red')
            return
            
        # check if name is too short
        nameLength = 0
        for char in name:
            nameLength = nameLength + 1
        if nameLength < 3:
            self.name_validation_label.config(text='‚ùå Name must be at least 3 characters long!', fg='red')
            return
            
        # check if name is too long
        if nameLength > 15:
            self.name_validation_label.config(text='‚ùå Name too long (max 15 characters)!', fg='red')
            return
            
        # check if name has only letters and numbers
        hasOnlyGoodChars = True
        for char in name:
            if char != " " and not char.isalnum():
                hasOnlyGoodChars = False
                break
        if not hasOnlyGoodChars:
            self.name_validation_label.config(text='‚ùå Name can only contain letters and numbers!', fg='red')
            return
        
        from utils import ScoreManager
        score_manager = ScoreManager()
        existing_records = score_manager.get_records()
        existing_names = []
        for record in existing_records:
            playerName = record.get('player', '')
            existing_names.append(playerName.lower())
        
        if name.lower() in existing_names:
            suggestions = [
                f"{name}1", f"{name}2", f"{name}2024", f"{name}_player", 
                f"Super{name}", f"{name}Math", f"{name}Star"
            ]
            # join first 3 suggestions with commas
            suggestion_text = ""
            for i in range(min(3, len(suggestions))):
                if i > 0:
                    suggestion_text = suggestion_text + ", "
                suggestion_text = suggestion_text + suggestions[i]
            
            self.name_validation_label.config(
                text=f'‚ùå "{name}" already exists in the leaderboard!\nüí° Try: {suggestion_text}', 
                fg='red'
            )
            return
        
        self.name_confirmed = True
        self.name_validation_label.config(text='‚úÖ Name confirmed! Choose your difficulty level.', fg='green')
        self.status_label.config(text=f'Welcome, {name}! Ready to play!', fg='green')

    def start_level(self, level):
        if not self.name_confirmed:
            self.status_label.config(text='Please confirm your name first!', fg='red')
            return
            
        name = self.name_var.get().strip()
        self.controller.player_name = name
        self.controller.selected_difficulty = level
        self.controller.show_frame('GamePage')

    def _add_floating_decorations(self):
        decorations = ['‚≠ê', 'üêö', 'üåä', 'üêô', 'ü¶Ä', 'üé®']
        positions = [
            (0.1, 0.1), (0.9, 0.1), (0.1, 0.9), (0.9, 0.9),
            (0.2, 0.2), (0.8, 0.2), (0.2, 0.8), (0.8, 0.8)
        ]
        
        # add decorations around the page
        for i, (relx, rely) in enumerate(positions):
            if i < len(decorations):
                deco_label = tk.Label(
                    self,
                    text=decorations[i],
                    font=('Comic Sans MS', 20),
                    bg='#FFE4B5',
                    fg='#FFD700'
                )
                deco_label.place(relx=relx, rely=rely, anchor='center')
    
    def reset_player_info(self):
        # clear everything and start over
        self.name_var.set('')
        self.name_confirmed = False
        
        self.name_validation_label.config(text='')
        self.status_label.config(text='Please enter and confirm your name first', fg='#2C3E50')

class GamePage(tk.Frame):
    def __init__(self, parent, controller):
        super().__init__(parent, bg='white')
        self.controller = controller
        self.jellyfish_manager = None
        
        self._active_timers = []
        self._game_active = False
        
        self.wrong_questions = []
        self.current_question_data = None
        
        self._create_widgets()
        self.reset_game()
    
    def _create_widgets(self):
        # set up the main game screen
        self.config(bg='#FFE4B5')
        main_frame = tk.Frame(self, bg='#FFE4B5')
        main_frame.pack(fill='both', expand=True, padx=15, pady=15)
        
        # top navigation bar
        top_nav = tk.Frame(main_frame, bg='#FFD700', height=60, bd=3, relief='raised')
        top_nav.pack(fill='x', pady=(0, 10))
        top_nav.pack_propagate(False)
        
        back_btn = tk.Button(
            top_nav, 
            text='üó∫Ô∏è Back to Map', 
            font=('Comic Sans MS', 12, 'bold'),
            bg='#FF6B35',
            fg='white',
            padx=15,
            pady=8,
            relief='raised',
            bd=3,
            cursor='hand2',
            command=self.return_to_map
        )
        back_btn.pack(side='right', padx=15, pady=10)
        
        game_title = tk.Label(
            top_nav,
            text='üßΩ SpongeBob Math Adventure üßΩ',
            font=('Comic Sans MS', 16, 'bold'),
            bg='#FFD700',
            fg='#2C3E50'
        )
        game_title.pack(side='left', padx=15, pady=10)
    
        # status bar - shows lives, score, timer
        status_bar = tk.Frame(main_frame, bg=STATUS_BAR_COLOR, height=50)
        status_bar.pack(fill='x', pady=(0, 10))
        
        # lives display - shows how many lives left
        self.lives_frame = tk.Frame(status_bar, bg=STATUS_BAR_COLOR)
        self.lives_frame.pack(side='left', padx=15)
        
        # try to load heart image for lives
        try:
            self.heart_img = tk.PhotoImage(file='assets/Images/heart.png')
            self.heart_img = self.heart_img.subsample(4, 4)  # make it smaller
        except Exception:
            self.heart_img = None  # if image fails, we'll use text instead
        
        # create 3 life hearts
        self.lives_labels = []
        for i in range(3):
            if self.heart_img:
                label = tk.Label(self.lives_frame, image=self.heart_img, bg=STATUS_BAR_COLOR)
            else:
                label = tk.Label(self.lives_frame, text='‚ô•', 
                            font=('Comic Sans MS', 20), 
                            fg='#FF6B6B', bg=STATUS_BAR_COLOR)
            label.pack(side='left', padx=2)
            self.lives_labels.append(label)
        
        # score display - shows current score
        self.score_label = tk.Label(
            status_bar, 
            text='Score: 0', 
            font=('Comic Sans MS', 16), 
            fg='#FFF44F',
            bg=STATUS_BAR_COLOR
        )
        self.score_label.pack(side='left', padx=15)
        
        # timer display - shows time left
        self.timer_label = tk.Label(
            status_bar, 
            text='Time: 20s', 
            font=('Comic Sans MS', 16), 
            fg='white', 
            bg=STATUS_BAR_COLOR
        )
        self.timer_label.pack(side='right', padx=15)
        
        # question counter - shows which question we're on
        self.counter_label = tk.Label(
            status_bar, 
            text='Question: 1/12', 
            font=('Comic Sans MS', 16), 
            fg='white', 
            bg=STATUS_BAR_COLOR
        )
        self.counter_label.pack(side='right', padx=15)
    
        # Question display - where the math problem shows up
        question_container = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        question_container.pack(fill='x', padx=15, pady=10)
        
        # Question title decoration - makes it look fun
        question_title = tk.Label(
            question_container,
            text='üßΩ Question Time! üßΩ',
            font=('Comic Sans MS', 12, 'bold'),
            bg='#FFD700',
            fg='#2C3E50'
        )
        question_title.pack(pady=(5, 0))
        
        self.question_label = tk.Label(
            question_container, 
            text='', 
            font=('Comic Sans MS', 16, 'bold'), 
            bg='#FFD700', 
            fg='#2C3E50',
            wraplength=600,
            pady=15
        )
        self.question_label.pack(fill='x', padx=15, pady=10)
    
        # Jellyfish canvas container - where the jellyfish swim around
        canvas_container = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        canvas_container.pack(fill='both', expand=True, pady=10)
        
        # Add canvas title decoration - tells player what to do
        canvas_title = tk.Frame(canvas_container, bg='#FFD700')
        canvas_title.pack(side='top', pady=(5, 0))
        
        title_label = tk.Label(
            canvas_title,
            text='üê† Click correct answer Under the Jellyfish! üê†',
            font=('Comic Sans MS', 16, 'bold'),
            bg='#FFD700',
            fg='#006994'
        )
        title_label.pack(side='left', padx=15)
        
        # Add SpongeBob decorations - makes it look cool
        decoration_label = tk.Label(
            canvas_title,
            text='üßΩ ü¶Ä üêô üê† ‚≠ê',
            font=('Comic Sans MS', 14),
            bg='#FFD700',
            fg='#FF6B35'
        )
        decoration_label.pack(side='right', padx=15)
        
        # Canvas border - gives it a nice frame
        canvas_border = tk.Frame(canvas_container, bg='#FF6B35', bd=2, relief='sunken')
        canvas_border.pack(fill='both', expand=True, padx=5, pady=5)
    
        self.canvas = tk.Canvas(canvas_border, bg='#87CEEB', highlightthickness=0)
        self.canvas.pack(fill='both', expand=True, padx=2, pady=2)
        
        # Add ocean decoration elements - bubbles and stuff
        self._add_ocean_decorations()
    
        # Feedback label - tells player if they got it right or wrong
        feedback_container = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')  # Use yellow background to ensure visibility
        feedback_container.pack(fill='x', pady=10)
        
        # Feedback title decoration - makes it look organized
        feedback_title = tk.Label(
            feedback_container,
            text='üí¨ Feedback Zone üí¨',
            font=('Comic Sans MS', 10, 'bold'),
            bg='#FFD700',
            fg='#2C3E50'
        )
        feedback_title.pack(pady=(3, 0))
        
        self.feedback_label = tk.Label(
            feedback_container, 
            text='', 
            font=('Comic Sans MS', 14, 'bold'), 
            bg='#FFD700',  # Use yellow background to ensure visibility in all difficulties
            fg='#2C3E50',
            height=1
        )
        self.feedback_label.pack(fill='x', padx=10, pady=5)
    
        # Bottom decoration bar - SpongeBob theme at the bottom
        bottom_decor = tk.Frame(main_frame, bg='#FFD700', height=40, bd=2, relief='sunken')
        bottom_decor.pack(side='bottom', fill='x', pady=(10, 0))
        bottom_decor.pack_propagate(False)
        
        # Add SpongeBob theme decorations - more fun stuff
        decor_label = tk.Label(
            bottom_decor,
            text='üêô ü¶Ä üßΩ üê† ‚≠ê üêö',
            font=('Comic Sans MS', 14),
            bg='#FFD700',
            fg='#FF6B35'
        )
        decor_label.pack(expand=True, pady=8)
    
    def _add_ocean_decorations(self):
        """Add ocean decoration elements - makes it look like underwater"""
        # Add bubble decorations - little bubbles floating around
        for i in range(8):
            x = 30 + i * 80
            y = 20 + (i % 3) * 15
            self.canvas.create_oval(
                x, y, x+8, y+8,
                fill='', outline='#E0F6FF', width=1,
                tags='decoration'
            )
        
        # Add starfish decorations - starfish on the ocean floor
        for i in range(4):
            x = 60 + i * 120
            y = 40 + (i % 2) * 20
            self.canvas.create_text(
                x, y, text='‚≠ê',
                font=('Comic Sans MS', 10),
                fill='#FFD700',
                tags='decoration'
            )
        
        # Add coral decorations - plants at the bottom
        for i in range(3):
            x = 50 + i * 150
            y = 350  # Fixed at bottom
            self.canvas.create_text(
                x, y, text='üåø',
                font=('Comic Sans MS', 12),
                fill='#228B22',
                tags='decoration'
            )

    def cancel_all_timers(self):
        # stop all the timers so they don't keep running
        for timer_id in self._active_timers:
            try:
                self.after_cancel(timer_id)
            except:
                pass  # ignore errors if timer already cancelled
        self._active_timers = []
        
        if self.jellyfish_manager:
            self.jellyfish_manager.stop_animations()

    def return_to_map(self):
        # ask player if they really want to quit
        if messagebox.askyesno("Confirm", "Exit current level? Progress will be lost."):
            self.cancel_all_timers()
            self._game_active = False
            self.controller.show_frame('PlayerInfoMapPage')

    def reset_game(self):
        # start a new game - reset everything
        self.cancel_all_timers()
        self._game_active = True
        self.question_count = 0
        self.score = 0
        self.lives = 3
        
        self.wrong_questions = []
        self.current_question_data = None
        
        # set background color based on difficulty
        self.bg_color = BACKGROUND_COLORS.get(self.controller.selected_difficulty, 'white')
        self.config(bg=self.bg_color)
        self.question_label.config(bg=self.bg_color)
        self.feedback_label.config(bg=self.bg_color)
        
        self.jellyfish_manager = JellyfishManager(self.canvas, self.controller.selected_difficulty)
        
        self.pb = ProblemBank(self.controller.selected_difficulty)
        
        # update life hearts display
        for i, label in enumerate(self.lives_labels):
            if i < self.lives:
                label.config(state='normal')
            else:
                label.config(state='disabled')
    
        self.next_question()
        return True

    def update_status(self):
        # update the display with current score and lives
        self.score_label.config(text=f'Score: {self.score}')
        
        # update life hearts
        for i, label in enumerate(self.lives_labels):
            if i < self.lives:
                label.config(state='normal')
            else:
                label.config(state='disabled')
        
        self.counter_label.config(text=f'Question: {self.question_count}/{QUESTIONS_PER_GAME}')

    def next_question(self):
        # move to the next question
        if not self._game_active:
            return
            
        if self.question_count >= QUESTIONS_PER_GAME:
            self.game_completed()
            return
            
        self.question_count += 1
        
        self._answer_checked = False
        
        self.cancel_all_timers()
        
        # get new problem from the problem bank
        problem, answer, options = self.pb.create_problem()
        self.correct_answer = answer
        self.options = options
        
        # save question data for review later
        self.current_question_data = {
            'question': problem,
            'correct_answer': answer,
            'options': options,
            'question_number': self.question_count,
            'user_answer': None
        }
        
        # update display with new question
        level_name = LEVEL_NAMES.get(self.controller.selected_difficulty, self.controller.selected_difficulty)
        self.question_label.config(text=f"{level_name}\n\n{problem}")
        self.feedback_label.config(text='')
        self.update_status()
        
        self.create_jellyfish(options)
        
        # start timer with increased time
        difficulty = self.controller.selected_difficulty
        self.time_left = TIME_PER_QUESTION.get(difficulty, 60)
        self.timer_label.config(text=f'Time: {self.time_left}s')
        self.start_timer()
    
    def start_timer(self):
        # start the countdown timer
        if not self._game_active:
            return
            
        self.update_timer()

    def update_timer(self):
        # update the timer every second
        if not self._game_active or not self.winfo_ismapped():
            return
        
        if self.time_left <= 0:
            self.handle_timeout()
            return
        
        self.time_left -= 1
        self.timer_label.config(text=f'Time: {self.time_left}s')
        
        # cancel old timer and start new one
        if self._active_timers:
            self.after_cancel(self._active_timers[0])
        
        timer_id = self.after(1000, self.update_timer)
        self._active_timers = [timer_id]

    def handle_timeout(self):
        # player ran out of time
        if not self._game_active:
            return
            
        # play sound
        try:
            self.controller.sound_manager.play_wrong()
        except:
            pass  # ignore if sound fails
        self.lives -= 1
        
        # save wrong answer for review
        if self.current_question_data:
            self.current_question_data['user_answer'] = 'No answer (timeout)'
            self.wrong_questions.append(self.current_question_data.copy())
        
        # show correct answer
        correct_answer = self.correct_answer
        if isinstance(correct_answer, (int, float)):
            correct_answer = str(correct_answer)
        
        self.feedback_label.config(text=f'Time up! The correct answer was {correct_answer}.', fg='#8B0000')
        self.update_status()
        
        self.disable_jellyfish()
        
        # continue or end game
        if self.lives <= 0:
            self.after(2000, self.game_over)
        else:
            self.after(2000, self.next_question)

    def create_jellyfish(self, options):
        # create jellyfish with answer options
        self.jellyfish = self.jellyfish_manager.create_jellyfish(options)
        
        # bind mouse events to each jellyfish
        for i in range(len(self.jellyfish)):
            self.canvas.tag_bind(f'jelly_{i}', '<ButtonPress-1>', 
                                lambda e, idx=i: self.jellyfish_manager.press_jellyfish(idx))
            
            self.canvas.tag_bind(f'jelly_{i}', '<ButtonRelease-1>', 
                                lambda e, idx=i, opt=options[i]: self.handle_jellyfish_release(idx, opt))
        
        self.jellyfish_manager.animate()
    
    def handle_jellyfish_release(self, jelly_index, option):
        self.jellyfish_manager.release_jellyfish(jelly_index)
        self.check_answer(option)
    
    def disable_jellyfish(self):
        if self.jellyfish_manager:
            self.jellyfish_manager.disable_interaction()

    def check_answer(self, selected):
        # prevent double clicks - only check once
        if hasattr(self, '_answer_checked') and self._answer_checked:
            return
        
        self._answer_checked = True
        self.disable_jellyfish()
        
        # save user's answer for review
        if self.current_question_data:
            self.current_question_data['user_answer'] = selected
        
        # check if answer is correct - handle different types
        if isinstance(self.correct_answer, tuple):
            try:
                parts = selected.split(',')
                if len(parts) != 2:
                    correct = False
                else:
                    selected_tuple = (float(parts[0]), float(parts[1]))
                    correct = (selected_tuple == self.correct_answer or
                              (selected_tuple[1], selected_tuple[0]) == self.correct_answer)
            except:
                correct = False
        else:
            try:
                correct = abs(float(selected) - float(self.correct_answer)) < 0.01
            except:
                correct = False
        
        if correct:
            self.handle_correct()
        else:
            self.handle_incorrect()

    def handle_correct(self):
        """Handle correct answer"""
        # Try to play sound, but don't crash if it fails
        try:
            self.controller.sound_manager.play_correct()
        except:
            pass  # Just continue without sound
        
        difficulty = getattr(self.controller, 'selected_difficulty', 'Easy')
        points = LEVEL_POINTS.get(difficulty, 10)
        
        self.score += points
        self.feedback_label.config(text=f'+{points} points! Correct!', fg='#228B22')
        self.update_status()
        
        self.after(1500, self.next_question)

    def handle_incorrect(self):
        """Handle incorrect answer"""
        # Try to play sound, but don't crash if it fails
        try:
            self.controller.sound_manager.play_wrong()
        except:
            pass  # Just continue without sound
        self.lives -= 1
        
        # Save wrong question
        if self.current_question_data:
            # Ensure user answer is saved
            if self.current_question_data.get('user_answer') is None:
                self.current_question_data['user_answer'] = 'No answer recorded'
            self.wrong_questions.append(self.current_question_data.copy())
        
        # Show correct answer
        correct_answer = self.correct_answer
        if isinstance(correct_answer, (int, float)):
            correct_answer = str(correct_answer)
        
        # User-friendly error messages with correct answer
        incorrect_messages = [
            f"Oops! The correct answer is {correct_answer}. Keep learning! üí™",
            f"Not quite right. The answer is {correct_answer}. You're getting better! üåü",
            f"Close! The correct answer is {correct_answer}. Don't give up! ‚ú®",
            f"That's okay! The answer is {correct_answer}. Every mistake helps you learn! üéØ"
        ]
        
        import random
        message = random.choice(incorrect_messages)
        self.feedback_label.config(text=message, fg='#8B0000')  # Dark red, more readable
        self.update_status()
        
        if self.lives <= 0:
            self.after(2000, self.game_over)  # Give more time to see correct answer
        else:
            self.after(2000, self.next_question)  # Give more time to see correct answer

    def save_score_to_leaderboard(self):
        """Save score to leaderboard without showing it"""
        player_name = getattr(self.controller, 'player_name', 'Player')
        difficulty = getattr(self.controller, 'selected_difficulty', 'Easy')
        
        # Save score to file
        score_manager = ScoreManager()
        score_manager.save_result(player_name, self.score, difficulty)
        
        # Save result to controller for highlighting
        self.controller.last_score = {
            'player': player_name,
            'score': self.score,
            'difficulty': difficulty
        }
    
    def save_and_show_leaderboard(self):
        """Save score and show leaderboard"""
        # Save the score first
        self.save_score_to_leaderboard()
        
        # Then show the leaderboard
        self.controller.show_frame('LeaderboardPage')
    
    def show_wrong_questions_summary(self):
        """Show wrong questions summary"""
        if not self.wrong_questions:
            messagebox.showinfo("No Wrong Questions", "Great job! You didn't get any questions wrong!")
            return
        
        # Create wrong questions summary window - larger window
        summary_window = tk.Toplevel()
        summary_window.title("üìù Wrong Questions Review")
        summary_window.geometry("1200x800")  # Larger window size
        summary_window.configure(bg='#E8F4FD')
        summary_window.resizable(True, True)
        
        # Get screen dimensions and center display
        screen_width = summary_window.winfo_screenwidth()
        screen_height = summary_window.winfo_screenheight()
        x = (screen_width - 1200) // 2
        y = (screen_height - 800) // 2
        summary_window.geometry(f"1200x800+{x}+{y}")
        
        # Center display
        summary_window.transient(self)
        summary_window.grab_set()
        
        # Main frame
        main_frame = tk.Frame(summary_window, bg='#E8F4FD')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Title
        title_frame = tk.Frame(main_frame, bg='#E8F4FD')
        title_frame.pack(fill='x', pady=(0, 15))
        
        tk.Label(
            title_frame,
            text="üìù Questions You Got Wrong - Review & Learn!",
            font=('Comic Sans MS', 18, 'bold'),
            bg='#E8F4FD',
            fg='#2C3E50'
        ).pack()
        
        # Statistics
        stats_frame = tk.Frame(title_frame, bg='#E8F4FD')
        stats_frame.pack(pady=5)
        
        total_questions = QUESTIONS_PER_GAME
        wrong_count = len(self.wrong_questions)
        correct_count = total_questions - wrong_count
        accuracy = (correct_count / total_questions) * 100 if total_questions > 0 else 0
        
        tk.Label(
            stats_frame,
            text=f"üìä Game Statistics:",
            font=('Comic Sans MS', 12, 'bold'),
            bg='#E8F4FD',
            fg='#2C3E50'
        ).pack()
        
        tk.Label(
            stats_frame,
            text=f"‚úÖ Correct: {correct_count} | ‚ùå Wrong: {wrong_count} | üìà Accuracy: {accuracy:.1f}%",
            font=('Comic Sans MS', 11),
            bg='#E8F4FD',
            fg='#006994'
        ).pack(pady=2)
        
        tk.Label(
            stats_frame,
            text="üìù Review your mistakes below and learn from them!",
            font=('Comic Sans MS', 10),
            bg='#E8F4FD',
            fg='#666666'
        ).pack(pady=2)
        
        # Create scrollable area
        canvas = tk.Canvas(main_frame, bg='#E8F4FD', highlightthickness=0)
        scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#E8F4FD')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Set canvas width to fit content
        canvas.configure(width=1150)  # Set fixed width
        
        # Display each wrong question
        for i, wrong_q in enumerate(self.wrong_questions, 1):
            question_frame = tk.Frame(scrollable_frame, bg='#FFE4E1', bd=2, relief='raised')
            question_frame.pack(fill='x', pady=10, padx=10)
            
            # Question number
            tk.Label(
                question_frame,
                text=f"Question #{wrong_q['question_number']}",
                font=('Comic Sans MS', 14, 'bold'),
                bg='#FFE4E1',
                fg='#8B0000'
            ).pack(anchor='w', padx=15, pady=(15, 10))
            
            # Question content
            tk.Label(
                question_frame,
                text=wrong_q['question'],
                font=('Comic Sans MS', 12),
                bg='#FFE4E1',
                fg='#2C3E50',
                wraplength=1000,  # Wider text wrapping
                justify='left'
            ).pack(anchor='w', padx=15, pady=8)
            
            # show all the choices that were available
            choices_container = tk.Frame(question_frame, bg='#FFE4E1')
            choices_container.pack(anchor='w', padx=15, pady=8)
            
            tk.Label(
                choices_container,
                text="üìã Available Choices:",
                font=('Comic Sans MS', 11, 'bold'),
                bg='#FFE4E1',
                fg='#2C3E50'
            ).pack(anchor='w')
            
            # loop through each choice and show it
            for choice_index, choice_value in enumerate(wrong_q['options']):
                choice_display = f"{chr(65+choice_index)}. {choice_value}"
                # mark the wrong answer with red background
                if wrong_q.get('user_answer') == choice_value:
                    background_color = '#FFB6C1'  # pink background for wrong choice
                    text_color = '#8B0000'  # dark red text
                    choice_display += " ‚ùå (You picked this)"
                else:
                    background_color = '#FFE4E1'
                    text_color = '#2C3E50'
                
                choice_label = tk.Label(
                    choices_container,
                    text=choice_display,
                    font=('Comic Sans MS', 11),
                    bg=background_color,
                    fg=text_color,
                    relief='solid',
                    bd=1,
                    padx=10,
                    pady=2
                )
                choice_label.pack(anchor='w', padx=25, pady=2, fill='x')
            
            # show what you picked vs what was right
            comparison_frame = tk.Frame(question_frame, bg='#FFE4E1')
            comparison_frame.pack(anchor='w', padx=15, pady=10, fill='x')
            
            # what you answered
            player_response = wrong_q.get('user_answer', 'No answer')
            if isinstance(player_response, (int, float)):
                player_response = str(player_response)
            
            tk.Label(
                comparison_frame,
                text=f"‚ùå Your Answer: {player_response}",
                font=('Comic Sans MS', 12, 'bold'),
                bg='#FFB6C1',
                fg='#8B0000',
                relief='solid',
                bd=1,
                padx=10,
                pady=5
            ).pack(side='left', padx=(0, 10))
            
            # what was actually correct
            right_answer = wrong_q['correct_answer']
            if isinstance(right_answer, (int, float)):
                right_answer = str(right_answer)
            
            tk.Label(
                comparison_frame,
                text=f"‚úÖ Correct Answer: {right_answer}",
                font=('Comic Sans MS', 12, 'bold'),
                bg='#90EE90',
                fg='#228B22',
                relief='solid',
                bd=1,
                padx=10,
                pady=5
            ).pack(side='left')
            
            # add a line to separate questions
            divider_line = tk.Frame(question_frame, height=2, bg='#8B0000')
            divider_line.pack(fill='x', padx=15, pady=10)
        
        # buttons at the bottom for navigation
        bottom_buttons = tk.Frame(main_frame, bg='#E8F4FD')
        bottom_buttons.pack(fill='x', pady=(15, 0))
        
        tk.Button(
            bottom_buttons,
            text="üè† Back to Menu",
            font=('Comic Sans MS', 12, 'bold'),
            bg='#FF9800',
            fg='white',
            padx=15,
            pady=8,
            command=lambda: [summary_window.destroy(), self.controller.show_frame('StartPage')]
        ).pack(side='left', padx=5)
        
        tk.Button(
            bottom_buttons,
            text="üèÜ View Leaderboard",
            font=('Comic Sans MS', 12, 'bold'),
            bg='#2196F3',
            fg='white',
            padx=15,
            pady=8,
            command=lambda: [summary_window.destroy(), self.save_and_show_leaderboard()]
        ).pack(side='left', padx=5)
        
        tk.Button(
            bottom_buttons,
            text="üéÆ Play Again",
            font=('Comic Sans MS', 12, 'bold'),
            bg='#4CAF50',
            fg='white',
            padx=15,
            pady=8,
            command=lambda: [summary_window.destroy(), self.reset_game(), self.controller.show_frame('GamePage')]
        ).pack(side='right', padx=5)
        
        # put the scrollable area together
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # make mouse wheel work for scrolling
        def scroll_with_mouse(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        canvas.bind_all("<MouseWheel>", scroll_with_mouse)
        
        # clean up when window closes
        def close_window_properly():
            canvas.unbind_all("<MouseWheel>")
            summary_window.destroy()
        
        summary_window.protocol("WM_DELETE_WINDOW", close_window_properly)

    def game_completed(self):
        """you finished all the questions!"""
        self._game_active = False
        self.cancel_all_timers()
        
        player_name = getattr(self.controller, 'player_name', 'Player')
        difficulty = getattr(self.controller, 'selected_difficulty', 'Easy')
        
        # save your score automatically
        self.save_score_to_leaderboard()
        
        # pick a random congratulatory message
        good_job_messages = [
            f"üéâ Amazing job, {player_name}! You're a math superstar! üåü",
            f"üèÜ Fantastic work! You've conquered the {difficulty} challenge!",
            f"‚ú® Incredible! You've mastered the {difficulty} level!",
            f"üéä Outstanding performance! You're ready for the next challenge!"
        ]
        
        import random
        message = random.choice(good_job_messages)
        
        # make a popup window with choices
        from tkinter import simpledialog
        
        # create the popup window
        dialog = tk.Toplevel()
        dialog.title("üéâ Level Complete! üéâ")
        dialog.geometry("1000x700")  # make it big enough
        dialog.configure(bg='#E8F4FD')
        dialog.resizable(True, True)
        
        # figure out where to put it on screen
        screen_width = dialog.winfo_screenwidth()
        screen_height = dialog.winfo_screenheight()
        x = (screen_width - 1000) // 2
        y = (screen_height - 700) // 2
        dialog.geometry(f"1000x700+{x}+{y}")
        
        # make it stay on top
        dialog.transient(self)
        dialog.grab_set()
        
        # main container for everything
        main_frame = tk.Frame(dialog, bg='#E8F4FD')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # put buttons at the top
        button_frame = tk.Frame(main_frame, bg='#E8F4FD')
        button_frame.pack(fill='x', pady=(0, 15))
        
        # tell user what buttons do
        tk.Label(
            button_frame,
            text="üìã Action Buttons:",
            font=('Comic Sans MS', 12, 'bold'),
            bg='#E8F4FD',
            fg='#2C3E50'
        ).pack(pady=(0, 5))
        
        play_again_var = tk.StringVar(value="")
        
        def play_again_clicked():
            play_again_var.set("play_again")
            dialog.destroy()
        
        def back_to_map_clicked():
            play_again_var.set("back_menu")
            dialog.destroy()
        
        def show_leaderboard_clicked():
            play_again_var.set("leaderboard")
            dialog.destroy()
        
        # group all the buttons together
        button_group = tk.Frame(button_frame, bg='#E8F4FD')
        button_group.pack(expand=True)
        
        tk.Button(
            button_group,
            text="üéÆ Play Again",
            font=('Comic Sans MS', 11, 'bold'),
            bg='#4CAF50',
            fg='white',
            padx=12,
            pady=6,
            command=play_again_clicked
        ).pack(side='left', padx=10)
        
        tk.Button(
            button_group,
            text="üó∫Ô∏è Map Page",
            font=('Comic Sans MS', 11, 'bold'),
            bg='#FF9800',
                fg='white',
            padx=12,
            pady=6,
            command=back_to_map_clicked
        ).pack(side='left', padx=10)
        
        tk.Button(
            button_group,
            text="üèÜ Leaderboard",
            font=('Comic Sans MS', 11, 'bold'),
            bg='#2196F3',
            fg='white',
            padx=12,
            pady=6,
            command=show_leaderboard_clicked
        ).pack(side='left', padx=10)
        
        # add review button if you got some wrong
        if self.wrong_questions:
            tk.Button(
                button_group,
                text="üìù Review Questions",
                font=('Comic Sans MS', 11, 'bold'),
                bg='#9C27B0',
                fg='white',
                padx=12,
                pady=6,
                command=self.show_questions_summary
            ).pack(side='left', padx=10)
        
        # show title and stats in a nice layout
        header_frame = tk.Frame(main_frame, bg='#E8F4FD')
        header_frame.pack(fill='x', pady=(0, 15))
        
        # fancy border around title
        title_border = tk.Frame(header_frame, bg='#FFD700', bd=3, relief='raised')
        title_border.pack(fill='x', pady=(0, 15))
        
        title_content = tk.Frame(title_border, bg='#FFF8DC', bd=2, relief='sunken')
        title_content.pack(fill='x', padx=5, pady=5)
        
        # party decorations
        celebration_frame = tk.Frame(title_content, bg='#FFF8DC')
        celebration_frame.pack(pady=(5, 0))
        
        tk.Label(
            celebration_frame,
            text="üéâ üèÜ üéä",
            font=('Comic Sans MS', 20),
            bg='#FFF8DC',
            fg='#FFD700'
        ).pack()
        
        tk.Label(
            title_content,
            text=message,
            font=('Comic Sans MS', 16, 'bold'),
            bg='#FFF8DC',
            fg='#2C3E50',
            wraplength=900
        ).pack(pady=10)
        
        # show your score and difficulty info
        stats_border = tk.Frame(header_frame, bg='#87CEEB', bd=2, relief='raised')
        stats_border.pack(fill='x', pady=10)
        
        stats_content = tk.Frame(stats_border, bg='#E0F6FF', bd=1, relief='sunken')
        stats_content.pack(fill='x', padx=3, pady=3)
        
        tk.Label(
            stats_content,
            text=f"üéØ Final Score: {self.score} points",
            font=('Comic Sans MS', 14, 'bold'),
            bg='#E0F6FF',
            fg='#006994'
        ).pack(pady=5)
        
        tk.Label(
            stats_content,
            text=f"üéÆ Difficulty: {difficulty}",
            font=('Comic Sans MS', 12),
            bg='#E0F6FF',
            fg='#006994'
        ).pack(pady=2)
        
        # show where you rank on leaderboard
        leaderboard_text, leaderboard_color = self._get_leaderboard_info(player_name, self.score)
        tk.Label(
            stats_content,
            text=leaderboard_text,
            font=('Comic Sans MS', 12, 'bold'),
            bg='#E0F6FF',
            fg=leaderboard_color
        ).pack(pady=2)
        
        # show how well you did if you got some wrong
        if self.wrong_questions:
            wrong_count = len(self.wrong_questions)
            total_questions = QUESTIONS_PER_GAME
            correct_count = total_questions - wrong_count
            accuracy = (correct_count / total_questions) * 100 if total_questions > 0 else 0
            
            # performance stats with nice border
            perf_border = tk.Frame(header_frame, bg='#98FB98', bd=2, relief='raised')
            perf_border.pack(fill='x', pady=10)
            
            perf_content = tk.Frame(perf_border, bg='#F0FFF0', bd=1, relief='sunken')
            perf_content.pack(fill='x', padx=3, pady=3)
            
            tk.Label(
                perf_content,
                text="üìä Performance Summary",
                font=('Comic Sans MS', 13, 'bold'),
                bg='#F0FFF0',
                fg='#228B22'
            ).pack(pady=5)
            
            tk.Label(
                perf_content,
                text=f"‚úÖ Correct: {correct_count} | ‚ùå Wrong: {wrong_count} | üìà Accuracy: {accuracy:.1f}%",
                font=('Comic Sans MS', 11, 'bold'),
                bg='#F0FFF0',
                fg='#2C3E50'
            ).pack(pady=3)
        
        # show the wrong questions if you got any
        if self.wrong_questions:
            # make a scrollable area for the wrong questions
            canvas = tk.Canvas(main_frame, bg='#E8F4FD', highlightthickness=0, height=400)
            scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
            scrollable_frame = tk.Frame(canvas, bg='#E8F4FD')
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # title for wrong questions
            tk.Label(
                scrollable_frame,
                text="üìù Wrong Questions Summary:",
                font=('Comic Sans MS', 14, 'bold'),
                bg='#E8F4FD',
                fg='#2C3E50'
            ).pack(pady=(0, 10))
            
            # show each wrong question
            for i, wrong_q in enumerate(self.wrong_questions, 1):
                # put each question in its own box
                question_frame = tk.Frame(scrollable_frame, bg='#FFE4E1', bd=2, relief='raised')
                question_frame.pack(fill='x', pady=5, padx=10)
                
                # question number
                tk.Label(
                    question_frame,
                    text=f"Question #{wrong_q['question_number']}",
                    font=('Comic Sans MS', 12, 'bold'),
                    bg='#FFE4E1',
                    fg='#8B0000'
                ).pack(anchor='w', padx=10, pady=(10, 5))
                
                # the actual question
                tk.Label(
                    question_frame,
                    text=wrong_q['question'],
                    font=('Comic Sans MS', 11),
                    bg='#FFE4E1',
                    fg='#2C3E50',
                    wraplength=800,
                    justify='left'
                ).pack(anchor='w', padx=10, pady=5)
                
                # what you said vs what was right
                answer_frame = tk.Frame(question_frame, bg='#FFE4E1')
                answer_frame.pack(anchor='w', padx=10, pady=5, fill='x')
                
                user_answer = wrong_q.get('user_answer', 'No answer')
                if isinstance(user_answer, (int, float)):
                    user_answer = str(user_answer)
                
                correct_answer = wrong_q['correct_answer']
                if isinstance(correct_answer, (int, float)):
                    correct_answer = str(correct_answer)
                
                tk.Label(
                    answer_frame,
                    text=f"‚ùå Your Answer: {user_answer}",
                    font=('Comic Sans MS', 11, 'bold'),
                    bg='#FFB6C1',
                    fg='#8B0000',
                    relief='solid',
                    bd=1,
                    padx=8,
                    pady=3
                ).pack(side='left', padx=(0, 10))
                
                tk.Label(
                    answer_frame,
                    text=f"‚úÖ Correct: {correct_answer}",
                    font=('Comic Sans MS', 11, 'bold'),
                    bg='#90EE90',
                    fg='#228B22',
                    relief='solid',
                    bd=1,
                    padx=8,
                    pady=3
                ).pack(side='left')
            
            # put the scrollable area together
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
        
        # remind user they can review questions
        if self.wrong_questions:
            hint_frame = tk.Frame(main_frame, bg='#FFFACD', bd=2, relief='raised')
            hint_frame.pack(fill='x', pady=10)
            
            tk.Label(
                hint_frame,
                text="üí° Tip: Click 'üìù Review Questions' button above to see detailed review of your mistakes!",
                font=('Comic Sans MS', 11, 'bold'),
                bg='#FFFACD',
                fg='#8B4513'
            ).pack(pady=8)
        
        # wait for user to pick something
        
        # wait for user to pick something
        dialog.wait_window()
        result = play_again_var.get()
        
        if result == "play_again":
            # start the same difficulty again
            self.reset_game()
            self.controller.show_frame('GamePage')
        elif result == "leaderboard":
            # show the leaderboard
            self.save_and_show_leaderboard()
        elif result == "back_menu":
            # go back to map page, keep player info
            self.reset_game()
            self.controller.show_frame('PlayerInfoMapPage')
        else:  # default to menu
            # go back to menu and reset player info
            self.reset_game()
            player_info_page = self.controller.page_frames['PlayerInfoMapPage']
            player_info_page.reset_player_info()
            self.controller.show_frame('PlayerInfoMapPage')

    def game_over(self):
        """you ran out of lives"""
        self._game_active = False
        self.cancel_all_timers()
        
        player_name = getattr(self.controller, 'player_name', 'Player')
        
        # save your score automatically
        self.save_score_to_leaderboard()
        
        # pick a random encouraging message
        encouraging_messages = [
            f"üí™ Don't worry, {player_name}! Every great mathematician started somewhere!",
            f"üåü Keep practicing, {player_name}! You're getting better with each try!",
            f"üéØ Nice effort, {player_name}! Math is a journey, not a destination!",
            f"‚ú® Great attempt, {player_name}! Learning from mistakes makes you stronger!"
        ]
        
        import random
        message = random.choice(encouraging_messages)
        
        # give advice based on difficulty level
        current_difficulty = getattr(self.controller, 'selected_difficulty', 'Easy')
        if current_difficulty == 'Easy':
            tip = "üí° Tip: Practice makes perfect! Try again to improve your score!"
        elif current_difficulty == 'Medium':
            tip = "üí° Tip: You're doing great! Try the Easy level to build confidence, or try Medium again!"
        else:  # Hard
            tip = "üí° Tip: Hard level is challenging! Try Medium or Easy to practice first!"
        
        # make a popup window for game over
        dialog = tk.Toplevel()
        dialog.title("üéÆ Game Over - But Don't Give Up! üéÆ")
        dialog.geometry("1000x700")  # make it big enough
        dialog.configure(bg='#E8F4FD')
        dialog.resizable(True, True)
        
        # center it on screen
        screen_width = dialog.winfo_screenwidth()
        screen_height = dialog.winfo_screenheight()
        x = (screen_width - 1000) // 2
        y = (screen_height - 700) // 2
        dialog.geometry(f"1000x700+{x}+{y}")
        
        # make it stay on top
        dialog.transient(self)
        dialog.grab_set()
        
        # main container
        main_frame = tk.Frame(dialog, bg='#E8F4FD')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # title and stats area
        header_frame = tk.Frame(main_frame, bg='#E8F4FD')
        header_frame.pack(fill='x', pady=(0, 15))
        
        # fancy border around title
        title_border = tk.Frame(header_frame, bg='#FFB6C1', bd=3, relief='raised')
        title_border.pack(fill='x', pady=(0, 15))
        
        title_content = tk.Frame(title_border, bg='#FFF0F5', bd=2, relief='sunken')
        title_content.pack(fill='x', padx=5, pady=5)
        
        # encouraging decorations
        encouragement_frame = tk.Frame(title_content, bg='#FFF0F5')
        encouragement_frame.pack(pady=(5, 0))
        
        tk.Label(
            encouragement_frame,
            text="üí™ üåü üéØ",
            font=('Comic Sans MS', 20),
            bg='#FFF0F5',
            fg='#FFB6C1'
        ).pack()
        
        tk.Label(
            title_content,
            text=message,
            font=('Comic Sans MS', 16, 'bold'),
            bg='#FFF0F5',
            fg='#2C3E50',
            wraplength=900
        ).pack(pady=10)
        
        # show score and difficulty info
        stats_border = tk.Frame(header_frame, bg='#87CEEB', bd=2, relief='raised')
        stats_border.pack(fill='x', pady=10)
        
        stats_content = tk.Frame(stats_border, bg='#E0F6FF', bd=1, relief='sunken')
        stats_content.pack(fill='x', padx=3, pady=3)
        
        tk.Label(
            stats_content,
            text=f"üéØ Final Score: {self.score} points",
            font=('Comic Sans MS', 14, 'bold'),
            bg='#E0F6FF',
            fg='#006994'
        ).pack(pady=5)
        
        tk.Label(
            stats_content,
            text=f"üéÆ Difficulty: {current_difficulty}",
            font=('Comic Sans MS', 12),
            bg='#E0F6FF',
            fg='#006994'
        ).pack(pady=2)
        
        # show leaderboard ranking
        leaderboard_text, leaderboard_color = self._get_leaderboard_info(player_name, self.score)
        tk.Label(
            stats_content,
            text=leaderboard_text,
            font=('Comic Sans MS', 12, 'bold'),
            bg='#E0F6FF',
            fg=leaderboard_color
        ).pack(pady=2)
        
        # show helpful tip
        tip_border = tk.Frame(header_frame, bg='#FFE4B5', bd=2, relief='raised')
        tip_border.pack(fill='x', pady=10)
        
        tip_content = tk.Frame(tip_border, bg='#FFF8DC', bd=1, relief='sunken')
        tip_content.pack(fill='x', padx=3, pady=3)
        
        tk.Label(
            tip_content,
            text="üí° Learning Tip",
            font=('Comic Sans MS', 12, 'bold'),
            bg='#FFF8DC',
            fg='#DAA520'
        ).pack(pady=3)
        
        tk.Label(
            tip_content,
            text=tip,
            font=('Comic Sans MS', 11),
            bg='#FFF8DC',
            fg='#2C3E50',
            wraplength=900
        ).pack(pady=3)
        
        # show performance stats if you got some wrong
        if self.wrong_questions:
            wrong_count = len(self.wrong_questions)
            total_questions = self.question_count
            correct_count = total_questions - wrong_count
            accuracy = (correct_count / total_questions) * 100 if total_questions > 0 else 0
            
            # performance stats with nice border
            perf_border = tk.Frame(header_frame, bg='#98FB98', bd=2, relief='raised')
            perf_border.pack(fill='x', pady=10)
            
            perf_content = tk.Frame(perf_border, bg='#F0FFF0', bd=1, relief='sunken')
            perf_content.pack(fill='x', padx=3, pady=3)
            
            tk.Label(
                perf_content,
                text="üìä Performance Summary",
                font=('Comic Sans MS', 13, 'bold'),
                bg='#F0FFF0',
                fg='#228B22'
            ).pack(pady=5)
            
            tk.Label(
                perf_content,
                text=f"‚úÖ Correct: {correct_count} | ‚ùå Wrong: {wrong_count} | üìà Accuracy: {accuracy:.1f}%",
                font=('Comic Sans MS', 11, 'bold'),
                bg='#F0FFF0',
                fg='#2C3E50'
            ).pack(pady=3)
        
        # remind user they can review questions
        if self.wrong_questions:
            hint_frame = tk.Frame(main_frame, bg='#FFFACD', bd=2, relief='raised')
            hint_frame.pack(fill='x', pady=10)
            
            tk.Label(
                hint_frame,
                text="üí° Tip: Click 'üìù Review Questions' button above to see detailed review of your mistakes!",
                font=('Comic Sans MS', 11, 'bold'),
                bg='#FFFACD',
                fg='#8B4513'
            ).pack(pady=8)
        
        # button area
        button_frame = tk.Frame(main_frame, bg='#E8F4FD')
        button_frame.pack(fill='x', pady=(15, 0))
        
        choice_var = tk.StringVar(value="")
        
        def try_again_clicked():
            choice_var.set("try_again")
            dialog.destroy()
        
        def back_to_map_clicked():
            choice_var.set("back_menu")
            dialog.destroy()
        
        def show_leaderboard_clicked():
            choice_var.set("leaderboard")
            dialog.destroy()
        
        # group all buttons together
        button_group = tk.Frame(button_frame, bg='#E8F4FD')
        button_group.pack(expand=True)
        
        tk.Button(
            button_group,
            text="üéÆ Try Again",
            font=('Comic Sans MS', 11, 'bold'),
            bg='#4CAF50',
            fg='white',
            padx=12,
            pady=6,
            command=try_again_clicked
        ).pack(side='left', padx=10)
        
        tk.Button(
            button_group,
            text="üó∫Ô∏è Map Page",
            font=('Comic Sans MS', 11, 'bold'),
            bg='#FF9800',
            fg='white',
            padx=12,
            pady=6,
            command=back_to_map_clicked
        ).pack(side='left', padx=10)
        
        tk.Button(
            button_group,
            text="üèÜ Leaderboard",
            font=('Comic Sans MS', 11, 'bold'),
            bg='#2196F3',
            fg='white',
            padx=12,
            pady=6,
            command=show_leaderboard_clicked
        ).pack(side='left', padx=10)
        
        # add review button if you got some wrong
        if self.wrong_questions:
            tk.Button(
                button_group,
                text="üìù Review Questions",
                font=('Comic Sans MS', 11, 'bold'),
                bg='#9C27B0',
                fg='white',
                padx=12,
                pady=6,
                command=self.show_questions_summary
            ).pack(side='left', padx=10)
        
        # wait for user to pick something
        dialog.wait_window()
        result = choice_var.get()
        
        if result == "try_again":
            # start the same difficulty again
            self.reset_game()
            self.controller.show_frame('GamePage')
        elif result == "leaderboard":
            # show the leaderboard
            self.save_and_show_leaderboard()
        elif result == "back_menu":
            # go back to map page, keep player info
            self.reset_game()
            self.controller.show_frame('PlayerInfoMapPage')
        else:  # default to menu
            # go back to menu and reset player info
            self.reset_game()
            player_info_page = self.controller.page_frames['PlayerInfoMapPage']
            player_info_page.reset_player_info()
            self.controller.show_frame('PlayerInfoMapPage')
    
    def _get_leaderboard_info(self, player_name, score):
        """figure out where the player ranks on the leaderboard"""
        try:
            from utils import ScoreManager
            score_manager = ScoreManager()
            high_scores = score_manager.get_records()
            
            # look for player's rank with current score
            player_rank = None
            player_on_leaderboard = False
            
            # see if player is on leaderboard with this score
            for i, score_entry in enumerate(high_scores, 1):
                if score_entry.get('player') == player_name and score_entry.get('score') == score:
                    player_rank = i
                    player_on_leaderboard = True
                    break
            
            # if not found with current score, check if player exists with different score
            if not player_on_leaderboard:
                for score_entry in high_scores:
                    if score_entry.get('player') == player_name:
                        player_on_leaderboard = True
                        break
            
            if player_rank:
                # player is on leaderboard with current score
                if player_rank == 1:
                    return f"üèÜ {player_name}, you're #1 on the leaderboard! Check the leaderboard to see your achievement!", '#FFD700'
                elif player_rank == 2:
                    return f"ü•à {player_name}, you're #2 on the leaderboard! Check the leaderboard to see how close you are to #1!", '#C0C0C0'
                elif player_rank == 3:
                    return f"ü•â {player_name}, you're #3 on the leaderboard! Check the leaderboard to see your ranking!", '#CD7F32'
                else:
                    return f"üìä {player_name}, you're #{player_rank} on the leaderboard! Check the leaderboard to see your position!", '#006994'
            elif player_on_leaderboard:
                # player is on leaderboard but with a different (higher) score
                return f"üìä {player_name}, you're already on the leaderboard! Check the leaderboard to see your best score!", '#228B22'
            else:
                # player is not on leaderboard at all
                if len(high_scores) > 0:
                    lowest_score = min(score_entry.get('score', 0) for score_entry in high_scores)
                    if score < lowest_score:
                        return f"üí™ {player_name}, check the leaderboard to see what score you need to beat! Keep practicing!", '#FF6B6B'
                    else:
                        return f"üéØ {player_name}, you're close to making the leaderboard! Check it to see how close you are!", '#FFA500'
                else:
                    return f"üéØ {player_name}, you're the first player! Check the leaderboard to see your score!", '#006994'
        except Exception as e:
            return f"üìä {player_name}, check the leaderboard to see how you rank!", '#006994'

    def show_questions_summary(self):
        """show wrong questions in a separate window"""
        if not self.wrong_questions:
            return
        
        # make a new window for the summary
        summary_window = tk.Toplevel()
        summary_window.title("üìù Questions Summary - Review Your Mistakes")
        summary_window.geometry("900x600")
        summary_window.configure(bg='#E8F4FD')
        summary_window.resizable(True, True)
        
        # put it in the center of screen
        screen_width = summary_window.winfo_screenwidth()
        screen_height = summary_window.winfo_screenheight()
        x = (screen_width - 900) // 2
        y = (screen_height - 600) // 2
        summary_window.geometry(f"900x600+{x}+{y}")
        
        summary_window.transient(self)
        summary_window.grab_set()
        
        # main container
        main_frame = tk.Frame(summary_window, bg='#E8F4FD')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # header area
        header_frame = tk.Frame(main_frame, bg='#E8F4FD')
        header_frame.pack(fill='x', pady=(0, 15))
        
        # fancy border around title
        title_border = tk.Frame(header_frame, bg='#FF6B6B', bd=3, relief='raised')
        title_border.pack(fill='x', pady=(0, 15))
        
        title_content = tk.Frame(title_border, bg='#FFE4E1', bd=2, relief='sunken')
        title_content.pack(fill='x', padx=5, pady=5)
        
        tk.Label(
            title_content,
            text="üìö Learning Review",
            font=('Comic Sans MS', 18, 'bold'),
            bg='#FFE4E1',
            fg='#8B0000'
        ).pack(pady=5)
        
        tk.Label(
            title_content,
            text="Review the questions you answered incorrectly to improve your skills!",
            font=('Comic Sans MS', 12),
            bg='#FFE4E1',
            fg='#2C3E50',
            wraplength=800
        ).pack(pady=5)
        
        # show performance stats
        wrong_count = len(self.wrong_questions)
        total_questions = QUESTIONS_PER_GAME
        correct_count = total_questions - wrong_count
        accuracy = (correct_count / total_questions) * 100 if total_questions > 0 else 0
        
        stats_frame = tk.Frame(header_frame, bg='#87CEEB', bd=2, relief='raised')
        stats_frame.pack(fill='x', pady=10)
        
        stats_content = tk.Frame(stats_frame, bg='#E0F6FF', bd=1, relief='sunken')
        stats_content.pack(fill='x', padx=3, pady=3)
        
        tk.Label(
            stats_content,
            text=f"üìä Performance: {correct_count} Correct | {wrong_count} Wrong | {accuracy:.1f}% Accuracy",
            font=('Comic Sans MS', 12, 'bold'),
            bg='#E0F6FF',
            fg='#006994'
        ).pack(pady=5)
        
        # area to show the questions
        questions_frame = tk.Frame(main_frame, bg='#E8F4FD')
        questions_frame.pack(fill='both', expand=True)
        
        # make a scrollable area for the questions
        canvas = tk.Canvas(questions_frame, bg='#E8F4FD', highlightthickness=0)
        scrollbar = tk.Scrollbar(questions_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#E8F4FD')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # make mouse wheel work for scrolling
        def scroll_with_mouse(event):
            try:
                canvas.yview_scroll(int(-1*(event.delta/120)), "units")
            except tk.TclError:
                # canvas was destroyed, ignore the error
                pass
        
        canvas.bind_all("<MouseWheel>", scroll_with_mouse)
        
        # clean up when window closes
        def close_window_properly():
            try:
                canvas.unbind_all("<MouseWheel>")
            except:
                pass
        
        summary_window.protocol("WM_DELETE_WINDOW", close_window_properly)
        
        # show each wrong question
        for i, wrong_q in enumerate(self.wrong_questions, 1):
            # put each question in its own box
            question_frame = tk.Frame(scrollable_frame, bg='#FFE4E1', bd=2, relief='raised')
            question_frame.pack(fill='x', pady=5, padx=5)
            
            # question number and the actual question
            tk.Label(
                question_frame,
                text=f"Question #{wrong_q['question_number']}",
                font=('Comic Sans MS', 12, 'bold'),
                bg='#FFE4E1',
                fg='#8B0000'
            ).pack(anchor='w', padx=10, pady=(10, 5))
            
            tk.Label(
                question_frame,
                text=wrong_q['question'],
                font=('Comic Sans MS', 11),
                bg='#FFE4E1',
                fg='#2C3E50',
                wraplength=800,
                justify='left'
            ).pack(anchor='w', padx=10, pady=5)
            
            # what you said vs what was right
            answer_frame = tk.Frame(question_frame, bg='#FFE4E1')
            answer_frame.pack(anchor='w', padx=10, pady=5, fill='x')
            
            user_answer = wrong_q.get('user_answer', 'No answer')
            if isinstance(user_answer, (int, float)):
                user_answer = str(user_answer)
            
            correct_answer = wrong_q['correct_answer']
            if isinstance(correct_answer, (int, float)):
                correct_answer = str(correct_answer)
            
            tk.Label(
                answer_frame,
                text=f"‚ùå Your Answer: {user_answer}",
                font=('Comic Sans MS', 11, 'bold'),
                bg='#FFB6C1',
                fg='#8B0000',
                relief='solid',
                bd=1,
                padx=8,
                pady=3
            ).pack(side='left', padx=(0, 10))
            
            tk.Label(
                answer_frame,
                text=f"‚úÖ Correct: {correct_answer}",
                font=('Comic Sans MS', 11, 'bold'),
                bg='#90EE90',
                fg='#228B22',
                relief='solid',
                bd=1,
                padx=8,
                pady=3
            ).pack(side='left')
        
        # put the scrollable area together
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # close button
        button_frame = tk.Frame(main_frame, bg='#E8F4FD')
        button_frame.pack(fill='x', pady=(15, 0))
        
        def close_window():
            try:
                canvas.unbind_all("<MouseWheel>")
            except:
                pass
            summary_window.destroy()
        
        tk.Button(
            button_frame,
            text="‚úÖ Got it! Close",
            font=('Comic Sans MS', 12, 'bold'),
            bg='#4CAF50',
            fg='white',
            padx=20,
            pady=8,
            command=close_window
        ).pack()
        
        # make sure window gets focus
        summary_window.focus_set()
        summary_window.wait_window()
