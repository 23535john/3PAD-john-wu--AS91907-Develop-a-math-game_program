import tkinter as tk
import random
import math
import json
import time
import os 
from utils import ScoreManager as DataManager  #  import score manager as DataManager

class JellyfishManager:
    """manages jellyfish stuff - uses real jellyfish pics"""
    SPEEDS = {'Easy': 5, 'Medium': 1.9, 'Hard': 1.7}  # jellyfish speed settings
    
    def __init__(self, canvas, difficulty):
        self.canvas = canvas
        self.difficulty = difficulty
        self.jellyfish = []
        self.active_animations = []
        self.jellyfish_images = self._load_jellyfish_images()
    
    def _load_jellyfish_images(self):
        """load jellyfish pics"""
        try:
            # try to load jellyfish PNG
            img = tk.PhotoImage(file='assets/Images/jellyfish.png')
            return {
                'main': img.subsample(3, 3),  # main jellyfish - smaller size
                'small': img.subsample(4, 4),  # even smaller jellyfish
                'glow': img.subsample(3, 3)    # glow effect pic
            }
        except Exception as e:
            print(f"Couldn't load jellyfish pics: {e}")
            return None
    
    def create_jellyfish(self, options):
        # creates the jellyfish with answer bubbles - this is where the magic happens
        self.canvas.delete('all')
        self.jellyfish = []
        positions = self._calculate_positions(len(options))
        
        for i, option in enumerate(options):
            x, y = positions[i]
            
            # ok so here we make the actual jellyfish - either with a pic or draw it
            if self.jellyfish_images:
                jelly_id = self.canvas.create_image(
                    x, y-25,  # jellyfish pic position - move up a bit
                    image=self.jellyfish_images['main'],
                    tags=('jellyfish', 'clickable', f'jelly_{i}')
                )
            else:
                # backup: make more realistic jellyfish shape
                jelly_id = self.canvas.create_oval(
                    x-20, y-20, x+20, y+20,
                    fill='#FFE4E1',  # softer pink
                    outline='#FFB6C1', width=2,  # softer outline
                    tags=('jellyfish', 'clickable', f'jelly_{i}')
                )
                
                # add jellyfish tentacles
                for j in range(3):
                    tentacle_x = x + random.randint(-15, 15)
                    tentacle_y = y + 20 + j * 8
                    self.canvas.create_line(
                        x, y+15, tentacle_x, tentacle_y,
                        fill='#FFB6C1', width=2,
                        tags=('jellyfish', 'tentacle', f'jelly_{i}')
                    )
            
            # now we make the bubble that shows the answer - spongebob style!
            bubble = self.canvas.create_oval(
                x-30, y+15, x+30, y+70,  # bubble below jellyfish, smaller
                fill='#F4E4BC',  # spongebob skin color
                outline='#DAA520', width=2,  # gold border
                tags=('jellyfish', 'clickable', 'bubble', f'jelly_{i}')
            )
            
            # add answer text - clearer to read
            text_id = self.canvas.create_text(
                x, y+42,  # text in center of bubble
                text=option, 
                font=('Arial', 14, 'bold'),  # slightly smaller font
                fill='#654321',  # dark brown text
                tags=('jellyfish', 'clickable', 'bubble_text', f'jelly_{i}')
            )
            
            # add text shadow - better readability
            shadow_id = self.canvas.create_text(
                x+1, y+43,  # shadow offset
                text=option, 
                font=('Arial', 14, 'bold'),
                fill='#8B4513',  # dark brown shadow
                tags=('jellyfish', 'text_shadow', f'jelly_{i}')
            )
            
            # set movement properties
            angle = random.uniform(0, 2 * math.pi)
            speed = self.SPEEDS.get(self.difficulty, 1.0)
            dx = math.cos(angle) * speed
            dy = math.sin(angle) * speed
            
            self.jellyfish.append({
                'jelly_id': jelly_id,
                'bubble': bubble,
                'text': text_id,
                'shadow': shadow_id,
                'dx': dx,
                'dy': dy,
                'x': x,
                'y': y,
                'animation_offset': random.uniform(0, 2 * math.pi),  # animation offset
                'pressed': False,  # pressed state
                'original_y': y  # original Y position for press effect
            })
        
        return self.jellyfish
    
    def animate(self):
        # this makes the jellyfish move around - pretty cool huh?
        width = self.canvas.winfo_width()
        height = self.canvas.winfo_height()
        
        if width < 100:
            width = 700
        if height < 100:
            height = 400
        
        #Increase boundary height
        boundary_height = int(height * 0.75)  # Reduced boundary height
        boundary_width = width - 80  # Left and right margins
        
        current_time = time.time()
        
        for jelly in self.jellyfish:
            #Calculate wave offset
            wave_x = math.sin(current_time * 0.8 + jelly['animation_offset']) * 2
            wave_y = math.cos(current_time * 1.2 + jelly['animation_offset']) * 2
            
            # Update jellyfosh position -Basic moving of jellyfish
            new_x = jelly['x'] + jelly['dx'] + wave_x
            new_y = jelly['y'] + jelly['dy'] + wave_y
            
            # Boundary check
            if new_x < 60:  # Add a buffer to prevent clipping
                new_x = 60
                jelly['dx'] = abs(jelly['dx']) * 0.9  # somothen bounce
            elif new_x > boundary_width:
                new_x = boundary_width
                jelly['dx'] = -abs(jelly['dx']) * 0.9  # somothen bounce
                
            if new_y < 60:  #AAdded margin
                new_y = 60
                jelly['dy'] = abs(jelly['dy']) * 0.9  # somothen bounce
            elif new_y > boundary_height:
                new_y = boundary_height
                jelly['dy'] = -abs(jelly['dy']) * 0.9  # somothen bounce
            
            # Update bubble position
            self.canvas.coords(jelly['jelly_id'], new_x, new_y-25)
            
            # Update bubble position
            self.canvas.coords(jelly['bubble'], 
                              new_x-30, new_y+15, 
                              new_x+30, new_y+70)
            
            # Update text 
            self.canvas.coords(jelly['text'], new_x, new_y+42)
            self.canvas.coords(jelly['shadow'], new_x+1, new_y+43)
            
            # make sure jellyfish don't bump into each other
            min_distance = 100  
            for other_jelly in self.jellyfish:
                if other_jelly != jelly:
                    dx = new_x - other_jelly['x']
                    dy = new_y - other_jelly['y']
                    distance = math.sqrt(dx*dx + dy*dy)
                    
                    if distance < min_distance:
                        # If too close, move away
                        if distance > 0:
                            push_x = (dx / distance) * (min_distance - distance) * 0.5
                            push_y = (dy / distance) * (min_distance - distance) * 0.5
                            new_x += push_x
                            new_y += push_y
                            
                            # Make sure the new position is within the boundary
                            new_x = max(60, min(boundary_width, new_x))
                            new_y = max(60, min(boundary_height, new_y))
            
            # save new position
            jelly['x'] = new_x
            jelly['y'] = new_y
        
        # Continue animation loop - 30fps
        anim_id = self.canvas.after(30, self.animate)
        self.active_animations.append(anim_id)
    
    def stop_animations(self):
        """Stop all animations"""
        for anim_id in self.active_animations:
            try:
                self.canvas.after_cancel(anim_id)
            except:
                pass
        self.active_animations = []
    
    def disable_interaction(self):
        """Ban user interaction"""
        self.canvas.tag_unbind('clickable', '<Button-1>')
        self.canvas.tag_unbind('clickable', '<ButtonPress-1>')
        self.canvas.tag_unbind('clickable', '<ButtonRelease-1>')
    
    def press_jellyfish(self, jelly_index):
        # when you click a jellyfish it does this cool effect
        if 0 <= jelly_index < len(self.jellyfish):
            jelly = self.jellyfish[jelly_index]
            if not jelly['pressed']:
                jelly['pressed'] = True
                #  Move the jellyfish up 
                self.canvas.coords(jelly['jelly_id'], jelly['x'], jelly['y']-20)
                self.canvas.coords(jelly['bubble'], 
                                 jelly['x']-30, jelly['y']+15, 
                                 jelly['x']+30, jelly['y']+70)
                self.canvas.coords(jelly['text'], jelly['x'], jelly['y']+42)
                self.canvas.coords(jelly['shadow'], jelly['x']+1, jelly['y']+43)
                
                # Add glow effect - more obvious color change
                self.canvas.itemconfig(jelly['bubble'], fill='#FFD700', outline='#FFA500', width=4)
                
                # Add text highlight effect
                self.canvas.itemconfig(jelly['text'], fill='#8B0000', font=('Arial', 16, 'bold'))
                self.canvas.itemconfig(jelly['shadow'], fill='#4B0082', font=('Arial', 16, 'bold'))
                
                # Add jellyfish image scaling effect (if using images)
                if self.jellyfish_images:
                    # Slightly enlarge jellyfish image
                    self.canvas.scale(jelly['jelly_id'], jelly['x'], jelly['y']-20, 1.1, 1.1)
    
    def release_jellyfish(self, jelly_index):
        """Release a jellyfish"""
        if 0 <= jelly_index < len(self.jellyfish):
            jelly = self.jellyfish[jelly_index]
            if jelly['pressed']:
                jelly['pressed'] = False
                # Restore jellyfish to original position
                self.canvas.coords(jelly['jelly_id'], jelly['x'], jelly['y']-25)
                self.canvas.coords(jelly['bubble'], 
                                 jelly['x']-30, jelly['y']+15, 
                                 jelly['x']+30, jelly['y']+70)
                self.canvas.coords(jelly['text'], jelly['x'], jelly['y']+42)
                self.canvas.coords(jelly['shadow'], jelly['x']+1, jelly['y']+43)
                
                # Restore bubble color
                self.canvas.itemconfig(jelly['bubble'], fill='#F4E4BC', outline='#DAA520', width=2)
                
                # Restore text style
                self.canvas.itemconfig(jelly['text'], fill='#654321', font=('Arial', 14, 'bold'))
                self.canvas.itemconfig(jelly['shadow'], fill='#8B4513', font=('Arial', 14, 'bold'))
                
                # Restore jellyfish image scaling (if using images)
                if self.jellyfish_images:
                    # Restore jellyfish image size
                    self.canvas.scale(jelly['jelly_id'], jelly['x'], jelly['y']-25, 1.0, 1.0)
    
    def _calculate_positions(self, count):
        # figures out where to put the jellyfish so they don't overlap
        width = max(self.canvas.winfo_width(), 700)
        height = min(max(self.canvas.winfo_height(), 400), 400) * 0.7
    
        if count == 1:
            return [(width // 2, height // 2)]

        positions = []
        center_x, center_y = width // 2, height // 2
        
        # Adjust radius based on jellyfish count to ensure sufficient spacing
        if count == 2:
            radius = min(width, height) * 0.25  # Use smaller radius for 2 jellyfish
        elif count == 3:
            radius = min(width, height) * 0.3   # Use medium radius for 3 jellyfish
        else:
            radius = min(width, height) * 0.35  # Use larger radius for 4 jellyfish
    
        for i in range(count):
            angle = 2 * math.pi * i / count
            x = center_x + radius * math.cos(angle)
            y = center_y + radius * math.sin(angle)
            
            # Add some randomness to the postions
            import random
            x += random.randint(-20, 20)
            y += random.randint(-20, 20)
        
            # Ensure within safe boundaries
            x = max(80, min(width - 80, x))
            y = max(80, min(height - 80, y))
        
            positions.append((x, y))
    
        return positions


class InstructionPage(tk.Frame):
    """instruction page that shows background image"""
    def __init__(self, parent, controller):
        super().__init__(parent, bg='#f0f8ff')
        self.controller = controller
        self._create_widgets()
    
    def _create_widgets(self):
        # try to load background image
        try:
            bg_image = tk.PhotoImage(file='assets/Images/Instruction.png')
            bg_label = tk.Label(self, image=bg_image)
            bg_label.image = bg_image
            bg_label.place(x=0, y=0, relwidth=1, relheight=1)
        except:
            # fallback to solid color if image fails
            self.config(bg='#E8F4FD')
        
        # back button - smaller and in top left
        back_btn = tk.Button(
            self, 
            text='â† Back', 
            font=('Comic Sans MS', 10, 'bold'),
            bg='#FFD700', 
            fg='#2C3E50',
            padx=8,
            pady=4,
            relief='raised',
            bd=2,
            command=lambda: self.controller.show_frame('PlayerInfoMapPage')
        )
        back_btn.place(relx=0.05, rely=0.05, anchor='nw')


class LeaderboardPage(tk.Frame):
    """leaderboard page"""
    def __init__(self, parent, controller):
        super().__init__(parent, bg='#f0f8ff')
        self.controller = controller
        self._create_widgets()
    
    def _create_widgets(self):
        """make the UI stuff"""
        # main frame - gradient background effect
        self.config(bg='#E8F4FD')  # ocean blue background
        main_frame = tk.Frame(self, bg='#E8F4FD')
        main_frame.pack(fill='both', expand=True, padx=15, pady=15)
        
        # add decorative border
        border_frame = tk.Frame(main_frame, bg='#FFD700', bd=3, relief='raised')
        border_frame.pack(fill='both', expand=True, padx=5, pady=5)
        
        # content frame
        content_frame = tk.Frame(border_frame, bg='#F0F8FF')
        content_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # title frame
        title_frame = tk.Frame(content_frame, bg='#F0F8FF')
        title_frame.pack(pady=10)
        
        tk.Label(
            title_frame, 
            text='ðŸ† Bikini Bottom Hall of Fame',
            font=('Comic Sans MS', 24, 'bold'),
            bg='#F0F8FF', 
            fg='#006994'
        ).pack(pady=10)
        
        self.leaderboard_frame = tk.Frame(content_frame, bg='#f0f8ff', bd=3, relief='groove')
        self.leaderboard_frame.pack(side='top', pady=10, fill='both', expand=True)
        
        menu_btn = tk.Button(
            content_frame, 
            text='ðŸ  Main Menu', 
            font=('Comic Sans MS', 14, 'bold'),
            bg='#FFD700', 
            fg='#2C3E50',
            padx=15,
            pady=8,
            relief='raised',
            bd=2,
            command=lambda: self.controller.show_frame('StartPage')
        )
        menu_btn.pack(side='bottom', pady=10)
        
        self.refresh()

    def refresh(self):
        """Refresh leaderboader"""
        for widget in self.leaderboard_frame.winfo_children():
            widget.destroy()
        
        header = tk.Frame(self.leaderboard_frame, bg='#5a9')
        header.pack(fill='x', pady=(0, 5))
        
        headers = ['Rank', 'Name', 'Score', 'Difficulty']
        widths = [8, 20, 10, 15]
        
        for i, h in enumerate(headers):
            tk.Label(
                header, 
                text=h, 
                font=('Comic Sans MS', 12, 'bold'),
                bg='#5a9', 
                fg='white',
                width=widths[i]
            ).grid(row=0, column=i, padx=2, sticky='ew')
        
        scores = DataManager().get_records()
        
        if not scores:
            no_scores = tk.Label(
                self.leaderboard_frame,
                text='No scores yet! Be the first to play!',
                font=('Comic Sans MS', 16),
                bg='#f0f8ff',
                pady=50
            )
            no_scores.pack(fill='both', expand=True)
            return
        
        scores_container = tk.Canvas(self.leaderboard_frame, bg='#f0f8ff', highlightthickness=0)
        scrollbar = tk.Scrollbar(self.leaderboard_frame, orient='vertical', command=scores_container.yview)
        scrollable_frame = tk.Frame(scores_container, bg='#f0f8ff')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: scores_container.configure(scrollregion=scores_container.bbox("all"))
        )
        scores_container.create_window((0, 0), window=scrollable_frame, anchor="nw")
        scores_container.configure(yscrollcommand=scrollbar.set)
        
        scores_container.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
        
        highlight_index = -1
        if hasattr(self.controller, 'last_score') and self.controller.last_score is not None:
            player_score = self.controller.last_score
            
            for i, score in enumerate(scores):
                score_player = score.get('player', score.get('name', 'Unknown'))
                player_name = player_score.get('player', player_score.get('name', 'Player'))
                
                score_value = score.get('score', 0)
                player_value = player_score.get('score', 0)
                
                score_difficulty = score.get('difficulty', score.get('level', 'Easy'))
                player_difficulty = player_score.get('difficulty', 'Easy')
                
                if (score_player == player_name and 
                    score_value == player_value and 
                    score_difficulty == player_difficulty):
                    highlight_index = i
                    break
        
        prev_score = None
        rank = 0
        skip = 0
        
        for i, score in enumerate(scores[:10]):
            current_score = score.get('score', 0)
            current_difficulty = score.get('difficulty', score.get('level', 'Easy'))
            
            if prev_score is None:
                prev_score = score
                rank = 1
                skip = 0
            else:
                prev_score_value = prev_score.get('score', 0)
                prev_difficulty = prev_score.get('difficulty', prev_score.get('level', 'Easy'))
                
                if current_score != prev_score_value or current_difficulty != prev_difficulty:
                    rank += 1 + skip
                    skip = 0
                else:
                    skip += 1
            
            if i == highlight_index:
                bg_color = '#FFD700'  # Golden highlight
            elif i % 2 == 0:
                bg_color = '#e6f7ff'
            else:
                bg_color = '#f0f8ff'
            
            row = tk.Frame(scrollable_frame, bg=bg_color)
            row.pack(fill='x', pady=2)
            
            tk.Label(
                row, 
                text=str(rank), 
                font=('Comic Sans MS', 12),
                bg=bg_color, 
                width=widths[0]
            ).grid(row=0, column=0)
            
            player_name = score.get('player', score.get('name', 'Unknown'))
            tk.Label(
                row, 
                text=player_name, 
                font=('Comic Sans MS', 12),
                bg=bg_color, 
                width=widths[1]
            ).grid(row=0, column=1)
            
            tk.Label(
                row, 
                text=str(score.get('score', 0)), 
                font=('Comic Sans MS', 12),
                bg=bg_color, 
                width=widths[2]
            ).grid(row=0, column=2)
            
            difficulty = score.get('difficulty', score.get('level', 'Easy'))
            tk.Label(
                row, 
                text=difficulty, 
                font=('Comic Sans MS', 12),
                bg=bg_color, 
                width=widths[3]
            ).grid(row=0, column=3)
            
            prev_score = score
